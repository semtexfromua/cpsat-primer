<!-- EDIT THIS PART VIA 08_lns.md -->

<a name="09-lns"></a>

## Використання CP-SAT для більших задач із Large Neighborhood Search

<!-- START_SKIP_FOR_README -->

![Cover Image LNS](https://raw.githubusercontent.com/d-krupke/cpsat-primer/main/images/logo_6.webp)

<!-- STOP_SKIP_FOR_README -->

CP-SAT чудово справляється з малими та середніми задачами. Але що робити, якщо
у вас дійсно велика задача? Один із варіантів — використати спеціальний клас
алгоритмів, відомий як «метаевристики», наприклад
[генетичний алгоритм](https://en.wikipedia.org/wiki/Genetic_algorithm). Але їх
важко налаштувати, і вони можуть не дати добрих результатів.

Інколи в наукових статтях можна побачити нові алгоритми з «крутими» назвами.
Це спокусливо, але часто такі методи — лише невеликі варіації старіших підходів
і можуть опускати ключові деталі, які змушують їх працювати. Якщо цікаво, про
цю проблему є обговорення в статті Соренсена
["Metaheuristics – The Metaphor Exposed"](http://onlinelibrary.wiley.com/doi/10.1111/itor.12001).

Добра новина? Вам не потрібно реалізовувати алгоритм, що імітує шлюбну поведінку
лісових жаб, щоб розв’язати задачу. Якщо ви вже вмієте користуватися CP-SAT, то
можете залишитися з ним і розв’язувати великі задачі без зайвих ускладнень. Ще
краще: ця техніка, відома як Large Neighborhood Search, часто перевершує інші
підходи.

### Чим відрізняється Large Neighborhood Search?

Багато традиційних методів генерують кілька «сусідів» навколо поточного
розв’язку та обирають найкращий. Але побудова кожного сусіднього розв’язку
потребує часу, що обмежує кількість варіантів, які можна перевірити.

Large Neighborhood Search (LNS) пропонує ефективніший підхід. Замість
побудови сусідів по одному, LNS формулює «міні-задачу», що змінює частини
поточного розв’язку. Зазвичай це означає випадково вибрати деякі змінні,
обнулити їх та використати CP-SAT (або подібний інструмент), щоб знайти
оптимальні нові значення в контексті решти розв’язку. Цей метод, відомий як
«destroy and repair», дозволяє ширше досліджувати сусідів без побудови кожного
окремо.

Крім того, LNS легко поєднувати з іншими методами, такими як генетичні
алгоритми. Якщо ви вже використовуєте генетичний алгоритм, можна «прокачати»
його, застосувавши CP-SAT для пошуку найкращого кросинговера двох чи більше
поточних рішень. Це ніби генетична інженерія, але без етичних дилем!

Якщо подивитися на логи CP-SAT, можна помітити, що він сам використовує LNS для
пошуку кращих рішень.

```
8 incomplete subsolvers: [feasibility_pump, graph_arc_lns, graph_cst_lns, graph_dec_lns, graph_var_lns, rins/rens, rnd_cst_lns, rnd_var_lns]
```

Чому ж недостатньо просто запускати CP-SAT, якщо він і так використовує LNS?
Причина в тому, що CP-SAT має бути відносно агностичним до задачі. Він не знає
структури вашої задачі, а отже не може використати цю інформацію для
покращення пошуку. Ви ж, навпаки, багато знаєте про свою задачу і можете
використати ці знання, щоб реалізувати ефективніший варіант.

**Література:**

- Загальна стаття про варіанти LNS:
  [Pisinger and Ropke - 2010](https://backend.orbit.dtu.dk/ws/portalfiles/portal/5293785/Pisinger.pdf)
- Загальний варіант (RINS), який використовує також CP-SAT:
  [Danna et al. 2005](https://link.springer.com/article/10.1007/s10107-004-0518-7)

Тепер розглянемо кілька прикладів.

#### Приклад 1: Рюкзак

Є рюкзак із певним лімітом ваги $C$, а також набір предметів $I$, які можна
покласти всередину. Кожен предмет $i\in I$ має вагу $w_i$ і цінність $v_i$. Мета
— максимізувати сумарну цінність, не перевищивши ліміт ваги.

```math
\max \sum_{i \in I} v_i x_i
```

```math
\text{s.t.} \sum_{i \in I} w_i x_i \leq C
```

```math
x_i \in \\{0,1\\}
```

Це одна з найпростіших NP-складних задач, яку можна розв’язати динамічним
програмуванням за псевдополіноміальний час. CP-SAT також здатен розв’язувати
багато великих екземплярів цієї задачі майже миттєво. Однак її проста структура
робить задачу хорошим прикладом, щоб продемонструвати Large Neighborhood
Search, навіть якщо цей алгоритм не надто корисний саме для рюкзака.

Проста ідея LNS: видалити кілька предметів із поточного розв’язку, обчислити
залишкову місткість, вибрати кілька додаткових предметів із тих, що залишилися,
і знайти оптимальний розв’язок, який заповнює залишкову місткість видаленими
та новими предметами. Повторюйте, доки вас влаштовує якість рішення. Кількість
видалених і доданих предметів можна зафіксувати так, щоб CP-SAT легко розв’язував
підзадачу. Повну реалізацію можна знайти в
[examples/lns_knapsack.ipynb](https://github.com/d-krupke/cpsat-primer/blob/main/examples/lns_knapsack.ipynb).

Подивімося лише один приклад:

Екземпляр: $C=151$,
$I=I_{0}(w=12, v=37),I_{1}(w=16, v=49),I_{2}(w=20, v=53),I_{3}(w=11, v=14),I_{4}(w=19, v=42),$
$\quad I_{5}(w=13, v=53),I_{6}(w=18, v=54),I_{7}(w=16, v=56),I_{8}(w=14, v=45),I_{9}(w=12, v=39),$
$\quad I_{10}(w=11, v=42),I_{11}(w=19, v=43),I_{12}(w=12, v=43),I_{13}(w=19, v=66),I_{14}(w=20, v=54),$
$\quad I_{15}(w=13, v=54),I_{16}(w=12, v=33),I_{17}(w=12, v=38),I_{18}(w=14, v=43),I_{19}(w=15, v=28),$
$\quad I_{20}(w=11, v=47),I_{21}(w=10, v=31),I_{22}(w=20, v=97),I_{23}(w=10, v=35),I_{24}(w=19, v=56),$
$\quad I_{25}(w=11, v=33),I_{26}(w=12, v=38),I_{27}(w=15, v=45),I_{28}(w=17, v=58),I_{29}(w=11, v=48),$
$\quad I_{30}(w=15, v=32),I_{31}(w=17, v=67),I_{32}(w=15, v=43),I_{33}(w=16, v=41),I_{34}(w=18, v=42),$
$\quad I_{35}(w=14, v=44),I_{36}(w=20, v=45),I_{37}(w=13, v=50),I_{38}(w=17, v=57),I_{39}(w=17, v=33),$
$\quad I_{40}(w=17, v=49),I_{41}(w=12, v=21),I_{42}(w=14, v=37),I_{43}(w=20, v=74),I_{44}(w=14, v=55),$
$\quad I_{45}(w=10, v=25),I_{46}(w=16, v=26),I_{47}(w=10, v=37),I_{48}(w=18, v=63),I_{49}(w=16, v=39),$
$\quad I_{50}(w=16, v=57),I_{51}(w=16, v=47),I_{52}(w=10, v=43),I_{53}(w=12, v=30),I_{54}(w=12, v=40),$
$\quad I_{55}(w=19, v=48),I_{56}(w=12, v=39),I_{57}(w=14, v=43),I_{58}(w=17, v=35),I_{59}(w=19, v=51),$
$\quad I_{60}(w=16, v=48),I_{61}(w=19, v=72),I_{62}(w=16, v=45),I_{63}(w=19, v=88),I_{64}(w=15, v=20),$
$\quad I_{65}(w=17, v=49),I_{66}(w=14, v=40),I_{67}(w=14, v=27),I_{68}(w=19, v=51),I_{69}(w=10, v=37),$
$\quad I_{70}(w=15, v=42),I_{71}(w=13, v=29),I_{72}(w=20, v=87),I_{73}(w=13, v=28),I_{74}(w=15, v=38),$
$\quad I_{75}(w=19, v=77),I_{76}(w=13, v=35),I_{77}(w=17, v=55),I_{78}(w=13, v=39),I_{79}(w=10, v=26),$
$\quad I_{80}(w=15, v=32),I_{81}(w=12, v=40),I_{82}(w=11, v=21),I_{83}(w=18, v=82),I_{84}(w=13, v=41),$
$\quad I_{85}(w=12, v=27),I_{86}(w=15, v=35),I_{87}(w=18, v=48),I_{88}(w=15, v=64),I_{89}(w=19, v=62),$
$\quad I_{90}(w=20, v=64),I_{91}(w=13, v=45),I_{92}(w=19, v=64),I_{93}(w=18, v=83),I_{94}(w=11, v=38),$
$\quad I_{95}(w=10, v=30),I_{96}(w=18, v=65),I_{97}(w=19, v=56),I_{98}(w=12, v=41),I_{99}(w=17, v=36)$

Початкове рішення з цінністю 442:
$\\{I_{0}, I_{1}, I_{2}, I_{3}, I_{4}, I_{5}, I_{6}, I_{7}, I_{8}, I_{9}\\}$

Тепер будемо повторювано видаляти 5 предметів із поточного розв’язку та
намагатися заповнити отриману місткість оптимальним рішенням, побудованим із
видалених предметів і ще 10 додаткових. Зауважте, що цей підхід по суті
розглядає $2^{5+10}=32768$ сусідніх рішень у кожній ітерації. Водночас ми могли
б легко масштабувати його, щоб розглядати $2^{100+900}\sim 10^{300}$ сусідніх
рішень у кожній ітерації завдяки неявному поданню сусідів і здатності CP-SAT
відтинати великі частини простору пошуку.

**Раунд 1 алгоритму LNS:**

- Видаляємо такі 5 предметів із розв’язку:
  $\\{I_{0}, I_{7}, I_{8}, I_{9}, I_{6}\\}$
- Відновлюємо розв’язок, розглядаючи таку підзадачу:
  - Підзадача: $C=72$,
    $I=\\{I_{6},I_{9},I_{86},I_{13},I_{47},I_{73},I_{0},I_{8},I_{7},I_{38},I_{57},I_{11},I_{60},I_{14}\\}$
- Знайдено таке рішення з цінністю 244 для підзадачі:
  $\\{I_{8}, I_{9}, I_{13}, I_{38}, I_{47}\\}$
- Об’єднуємо
  $\\{I_{1}, I_{2}, I_{3}, I_{4}, I_{5}\\}\cup \\{I_{8}, I_{9}, I_{13}, I_{38}, I_{47}\\}$
- Нове рішення з цінністю 455:
  $\\{I_{1}, I_{2}, I_{3}, I_{4}, I_{5}, I_{8}, I_{9}, I_{13}, I_{38}, I_{47}\\}$

**Раунд 2 алгоритму LNS:**

- Видаляємо такі 5 предметів із розв’язку:
  $\\{I_{3}, I_{13}, I_{2}, I_{9}, I_{1}\\}$
- Відновлюємо розв’язок, розглядаючи таку підзадачу:
  - Підзадача: $C=78$,
    $I=\\{I_{13},I_{9},I_{84},I_{41},I_{15},I_{42},I_{74},I_{16},I_{3},I_{1},I_{2},I_{67},I_{50},I_{89},I_{43}\\}$
- Знайдено таке рішення з цінністю 275 для підзадачі:
  $\\{I_{1}, I_{15}, I_{43}, I_{50}, I_{84}\\}$
- Об’єднуємо
  $\\{I_{4}, I_{5}, I_{8}, I_{38}, I_{47}\\}\cup \\{I_{1}, I_{15}, I_{43}, I_{50}, I_{84}\\}$
- Нове рішення з цінністю 509:
  $\\{I_{1}, I_{4}, I_{5}, I_{8}, I_{15}, I_{38}, I_{43}, I_{47}, I_{50}, I_{84}\\}$

**Раунд 3 алгоритму LNS:**

- Видаляємо такі 5 предметів із розв’язку:
  $\\{I_{8}, I_{43}, I_{84}, I_{1}, I_{50}\\}$
- Відновлюємо розв’язок, розглядаючи таку підзадачу:
  - Підзадача: $C=79$,
    $I=\\{I_{84},I_{76},I_{34},I_{16},I_{37},I_{20},I_{8},I_{43},I_{50},I_{1},I_{12},I_{35},I_{53}\\}$
- Знайдено таке рішення з цінністю 283 для підзадачі:
  $\\{I_{8}, I_{12}, I_{20}, I_{37}, I_{50}, I_{84}\\}$
- Об’єднуємо
  $\\{I_{4}, I_{5}, I_{15}, I_{38}, I_{47}\\}\cup \\{I_{8}, I_{12}, I_{20}, I_{37}, I_{50}, I_{84}\\}$
- Нове рішення з цінністю 526:
  $\\{I_{4}, I_{5}, I_{8}, I_{12}, I_{15}, I_{20}, I_{37}, I_{38}, I_{47}, I_{50}, I_{84}\\}$

**Раунд 4 алгоритму LNS:**

- Видаляємо такі 5 предметів із розв’язку:
  $\\{I_{37}, I_{4}, I_{20}, I_{5}, I_{15}\\}$
- Відновлюємо розв’язок, розглядаючи таку підзадачу:
  - Підзадача: $C=69$,
    $I=\\{I_{37},I_{4},I_{20},I_{15},I_{82},I_{41},I_{56},I_{76},I_{85},I_{5},I_{32},I_{57},I_{7},I_{67}\\}$
- Знайдено таке рішення з цінністю 260 для підзадачі:
  $\\{I_{5}, I_{7}, I_{15}, I_{20}, I_{37}\\}$
- Об’єднуємо
  $\\{I_{8}, I_{12}, I_{38}, I_{47}, I_{50}, I_{84}\\}\cup \\{I_{5}, I_{7}, I_{15}, I_{20}, I_{37}\\}$
- Нове рішення з цінністю 540:
  $\\{I_{5}, I_{7}, I_{8}, I_{12}, I_{15}, I_{20}, I_{37}, I_{38}, I_{47}, I_{50}, I_{84}\\}$

**Раунд 5 алгоритму LNS:**

- Видаляємо такі 5 предметів із розв’язку:
  $\\{I_{38}, I_{12}, I_{20}, I_{47}, I_{37}\\}$
- Відновлюємо розв’язок, розглядаючи таку підзадачу:
  - Підзадача: $C=66$,
    $I=\\{I_{20},I_{47},I_{37},I_{86},I_{58},I_{56},I_{54},I_{38},I_{12},I_{39},I_{68},I_{75},I_{66},I_{2},I_{99}\\}$
- Знайдено таке рішення з цінністю 254 для підзадачі:
  $\\{I_{12}, I_{20}, I_{37}, I_{47}, I_{75}\\}$
- Об’єднуємо
  $\\{I_{5}, I_{7}, I_{8}, I_{15}, I_{50}, I_{84}\\}\cup \\{I_{12}, I_{20}, I_{37}, I_{47}, I_{75}\\}$
- Нове рішення з цінністю 560:
  $\\{I_{5}, I_{7}, I_{8}, I_{12}, I_{15}, I_{20}, I_{37}, I_{47}, I_{50}, I_{75}, I_{84}\\}$

#### Приклад 2: Різні околиці для задачі комівояжера

Просто видалити частину розв’язку й потім намагатися його полагодити — не
найефективніший підхід. У цьому розділі ми розглянемо різні околиці для задачі
комівояжера (TSP). Геометрія TSP не лише дозволяє ефективні околиці, але й дає
візуально привабливі представлення. Коли у вас є кілька стратегій околиць, їх
можна динамічно інтегрувати за допомогою Adaptive Large Neighborhood Search
(ALNS).

Зображення ілюструє процес оптимізації маршруту, який має пройти через зелені
зони з урахуванням вартості поворотів, у вбудованому графі (mesh). Оптимізація
полягає у виборі конкретних регіонів (позначених червоним) і обчисленні
оптимального туру в їхніх межах. Із перебігом ітерацій початковий маршрут
зазвичай покращується, хоча деякі ітерації можуть не дати жодного поліпшення.
Червоні області вибираються через високу вартість маршруту в них. Після
оптимізації центр такого регіону додається до tabu-списку, щоб його не обирали
знову.

|                                                                   ![Large Neighborhood Search Geometry Example](https://github.com/d-krupke/cpsat-primer/blob/main/images/lns_pcpp.png)                                                                   |
| :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
| Large Neighborhood Search для планування покриття шляхом повторного вибору геометричної області (червоної) та оптимізації маршруту всередині неї. Червоні частини маршруту показують зміни ітерації. Читайте зліва направо та зверху вниз. |

Як визначити відповідний розмір регіону для вибору? Є два основні варіанти:
провести попередні експерименти або адаптивно налаштовувати розмір під час
пошуку. Просто задайте ліміт часу на кожну ітерацію. Якщо розв’язувач не
встигає оптимізувати в межах цього часу — зменшуйте розмір регіону. Якщо
встигає — збільшуйте. Використання експоненційних коефіцієнтів допоможе швидко
наблизити розмір до оптимального. Втім, важливо пам’ятати, що такий підхід
припускає порівнянну складність підзадач і може потребувати додаткових умов.

Для евклідової задачі комівояжера, на відміну від mesh, оптимізація регіонів не
є простою. Є кілька ефективних стратегій, наприклад використання сегмента
попереднього туру замість геометричної області. Якщо реалізувати кілька різних
околиц і оцінювати їхню результативність, можна давати вищу ймовірність
вибору найуспішнішим. Цей підхід показано в анімації, створеній двома моїми
студентами, Габріелем Ґерке та Лауренцом Ілльнером. Вони реалізували чотири
різні околиці та застосували ALNS, щоб динамічно обирати найефективнішу.

|                                                                                                                                                                         ![ALNS TSP](https://github.com/d-krupke/cpsat-primer/blob/main/images/alns_tsp_compr.gif)                                                                                                                                                                         |
| :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
| Анімація Adaptive Large Neighborhood Search для класичної задачі комівояжера. Використовуються чотири різні стратегії околиць, які випадково обираються з імовірністю, що залежить від їхнього успіху в попередніх ітераціях. Якщо подивитися логи останньої (v9.8) версії CP-SAT, він також оцінює ефективність своїх LNS-стратегій і частіше використовує найкращі (алгоритм UCB1). |

#### Багаторукий бандит: дослідження vs. використання

Наявність кількох стратегій для кожної ітерації LNS — це добре, але як вибрати,
яку використовувати? Можна вибирати випадково, але це неефективно, адже
ймовірність обрати найкращу стратегію низька. Можна завжди обирати стратегію, що
раніше добре працювала, але тоді ви ризикуєте не знайти ще кращу. Це класична
дилема «дослідження vs. використання» (exploration vs. exploitation). З одного
боку, хочеться використовувати стратегії, які вже дали результат, а з іншого —
потрібно досліджувати нові, потенційно кращі.

На щастя, ця проблема добре вивчена як
[задача багаторукого бандита](https://en.wikipedia.org/wiki/Multi-armed_bandit),
і існує багато ефективних рішень. Один із популярних підходів — алгоритм Upper
Confidence Bound (UCB1). Я хотів звернути увагу на цю дилему, щоб ви знали: над
нею вже багато працювали і розробили витончені стратегії.

На практиці CP-SAT планує свої LNS-стратегії за простим принципом round-robin,
що відображається однаковою кількістю викликів у логах. Коли робітничий потік
завершує роботу, він запускає ітерацію з наступною стратегією зі списку, що
призводить до рівномірного розподілу викликів. У цьому прикладі видно, що
стратегія `'routing_path_lns'` була найуспішнішою — вона покращувала поточне
рішення 41 раз із 65 викликів. Можливо, є простір для покращення, застосувавши
більш просунутий алгоритм вибору стратегій. Однак важливо враховувати відносно
невелику кількість викликів для кожної стратегії в поєднанні зі спадною та
шумною віддачею. Якщо ітерацій небагато, то просунутий алгоритм може не мати
достатньо даних для надійних рішень.

```
LNS stats                Improv/Calls  Closed  Difficulty  TimeLimit
       'graph_arc_lns':          5/65     49%        0.26       0.10
       'graph_cst_lns':          4/65     54%        0.47       0.10
       'graph_dec_lns':          3/65     49%        0.26       0.10
       'graph_var_lns':          4/66     55%        0.56       0.10
           'rins/rens':         23/66     39%        0.03       0.10
         'rnd_cst_lns':         12/66     50%        0.19       0.10
         'rnd_var_lns':          6/66     52%        0.36       0.10
    'routing_path_lns':         41/65     48%        0.10       0.10
  'routing_random_lns':         24/65     52%        0.26       0.10
```

> [!TIP]
>
> Ми вважаємо ефективною таку просту процедуру:
>
> - Починайте зі стратегії, що орієнтована на «низькосяжні плоди», тобто
>   відносно швидко сходиться.
> - Якщо прогрес зупинився, випадково обирайте нову стратегію з попередньо
>   визначеного пулу.
>
> Передбачити оптимальну стратегію на кожному етапі складно, адже найкраща
> стратегія змінюється в процесі пошуку, і, можливо, це не варте зусиль. Такий
> простий підхід використовує робочу стратегію, доки вона не зупиниться, а тоді
> досліджує нову, автоматично віддаючи перевагу тим, що приносять прогрес. Щоб
> уникнути «залипання» на повільно збіжній стратегії, за бажанням можна
> примусово перемикатися після певної кількості ітерацій.
