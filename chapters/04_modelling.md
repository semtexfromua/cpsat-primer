<!--EDIT THIS PART VIA 04_modelling.md -->

<a name="04-modelling"></a>

## Базове моделювання

<!-- START_SKIP_FOR_README -->

![Обкладинка «Моделювання»](https://raw.githubusercontent.com/d-krupke/cpsat-primer/main/images/logo_2.webp)

<!-- STOP_SKIP_FOR_README -->

У цьому розділі ми занурюємося в базові можливості моделювання CP-SAT. CP-SAT
надає широкий набір обмежень, ближчий до високорівневих мов моделювання на кшталт
MiniZinc, ніж до традиційного змішаного цілочисельного програмування (MIP).
Наприклад, він пропонує обмеження `all_different` та
`add_multiplication_equality`. Такі просунуті можливості зменшують потребу
моделювати складну логіку виключно через лінійні обмеження, хоча й роблять
інтерфейс складнішим. Водночас не всі обмеження однаково ефективні: лінійні та
булеві обмеження зазвичай найефективніші, тоді як обмеження на кшталт
`add_multiplication_equality` можуть суттєво вимагати більше ресурсів.

> [!TIP]
>
> Якщо ви переходите зі змішаного цілочисельного програмування (MIP), ви можете
> бути звиклими вручну реалізовувати високорівневі обмеження і підбирати параметри
> Big-M для кращої продуктивності. У CP-SAT такі ручні налаштування зазвичай не
> потрібні. CP-SAT працює інакше, ніж типові MIP-розв’язувачі, менше спираючись
> на лінійну релаксацію і більше — на внутрішній SAT-розв’язувач та пропагатори,
> які ефективно керують логічними обмеженнями. Користуйтеся високорівневими
> обмеженнями — вони часто ефективніші в CP-SAT.

Цей праймер розширено так, щоб охопити всі обмеження в двох розділах, із різними
прикладами, які ілюструють контексти їхнього застосування. Однак майстерність
моделювання — це значно більше, ніж знання обмежень. Вона вимагає глибокого
розуміння принципів і технік, що роблять моделі ефективними та застосовними до
реальних задач.

Для детальнішого вивчення моделювання варто звернутися до книги
«Model Building in Mathematical Programming» автора H. Paul Williams, яка
дає ґрунтовне уявлення про предмет і містить практичні приклади. Хоча ця книга
не специфічна для CP-SAT, базові техніки та концепції є універсальними. Також
тим, хто лише знайомиться з темою або переходить з MIP-рішень, може бути корисно
вивчити підхід до моделювання в Gurobi через цей
[відеокурс](https://www.youtube.com/playlist?list=PLHiHZENG6W8CezJLx_cw9mNqpmviq3lO9).
Хоча багато принципів збігаються, деякі стратегії, специфічні для CP-SAT, краще
покривають випадки, де традиційні MIP-розв’язувачі мають труднощі.

Додаткові ресурси з математичного моделювання (не специфічні для CP-SAT):

- [Math Programming Modeling Basics від Gurobi](https://www.gurobi.com/resources/math-programming-modeling-basics/):
  ресурс дає міцний вступ до основ математичного моделювання.
- [Modeling with Gurobi Python](https://www.youtube.com/playlist?list=PLHiHZENG6W8CezJLx_cw9mNqpmviq3lO9):
  комплексний відеокурс із моделювання в Gurobi, який підкреслює концепції,
  що також застосовні до CP-SAT.
- [Model Building in Mathematical Programming від H. Paul Williams](https://www.wiley.com/en-us/Model+Building+in+Mathematical+Programming%2C+5th+Edition-p-9781118443330):
  докладний путівник із технік математичного моделювання.

> [!TIP]
>
> Для старту з побудови оптимізаційних моделей загалом я дуже рекомендую допис
> [The Art Of Not Making It An Art](https://www.gurobi.com/resources/optimization-modeling-the-art-of-not-making-it-an-art/).
> Він чудово підсумовує фундаментальні принципи успішного ведення
> оптимізаційного проєкту незалежно від конкретної мови чи розв’язувача.

---

**Елементи:**

- [Змінні](#04-modelling-variables): `new_int_var`, `new_bool_var`,
  `new_constant`, `new_int_var_series`, `new_bool_var_series`
  - [Змінні з користувацьким доменом](#04-modelling-domain-variables):
    `new_int_var_from_domain`
- [Цілі](#04-modelling-objectives): `minimize`, `maximize`
- [Лінійні обмеження](#04-modelling-linear-constraints): `add`,
  `add_linear_constraint`
- [Логічні обмеження (пропозиційна логіка)](#04-modelling-logic-constraints):
  `add_implication`, `add_bool_or`, `add_at_least_one`, `add_at_most_one`,
  `add_exactly_one`, `add_bool_and`, `add_bool_xor`
- [Умовні обмеження (реїфікація)](#04-modelling-conditional-constraints):
  `only_enforce_if`
- [Абсолютні значення та Max/Min](#04-modelling-absmaxmin): `add_min_equality`,
  `add_max_equality`, `add_abs_equality`
- [Множення, ділення і модуль](#04-modelling-multdivmod):
  `add_modulo_equality`, `add_multiplication_equality`, `add_division_equality`
- [All Different](#04-modelling-alldifferent): `add_all_different`
- [Домени та комбінації](#04-modelling-table): `add_allowed_assignments`,
  `add_forbidden_assignments`
- [Масиви/обмеження елемента](#04-modelling-element): `add_element`,
  `add_inverse`

Більш просунуті обмеження `add_circuit`, `add_multiple_circuit`,
`add_automaton`,`add_reservoir_constraint`,
`add_reservoir_constraint_with_active`, `new_interval_var`,
`new_interval_var_series`, `new_fixed_size_interval_var`,
`new_optional_interval_var`, `new_optional_interval_var_series`,
`new_optional_fixed_size_interval_var`,
`new_optional_fixed_size_interval_var_series`, `add_no_overlap`,
`add_no_overlap_2d` та `add_cumulative` розглянуто в наступному розділі.

---

<a name="04-modelling-variables"></a>

### Змінні

У CP-SAT є два важливі типи змінних: булеві та цілочисельні
(які насправді перетворюються на булеві, але про це пізніше). Є також, наприклад,
[інтервальні змінні](https://developers.google.com/optimization/reference/python/sat/python/cp_model#intervalvar),
але це радше комбінація цілочисельних змінних, і їх розглянуто
[пізніше](#04-modelling-intervals). Для цілочисельних змінних потрібно задати
нижню та верхню межі.

```python
model = cp_model.CpModel()

# Цілочисельна змінна z з межами -100 <= z <= 100
z = model.new_int_var(-100, 100, "z")  # новий синтаксис
z_ = model.NewIntVar(-100, 100, "z_")  # старий синтаксис

# Булева змінна b
b = model.new_bool_var("b")  # новий синтаксис
b_ = model.NewBoolVar("b_")  # старий синтаксис

# Неявне заперечення b:
not_b = ~b  # буде 1, якщо b = 0, і 0, якщо b = 1
not_b_ = b.Not()  # старий синтаксис
```

Додатково можна використовувати `model.new_int_var_series` і
`model.new_bool_var_series`, щоб створювати кілька змінних одразу з pandas Index.
Це особливо зручно, якщо дані подані в pandas DataFrame. Проте з точки зору
продуктивності виграшу немає — це лише зручніше.

```python
model = cp_model.CpModel()

# Створюємо Index від 0 до 9
index = pd.Index(range(10), name="index")

# Створюємо pandas Series з 10 цілочисельних змінних відповідно до індексу
xs = model.new_int_var_series("x", index, 0, 100)

# Список булевих змінних
df = pd.DataFrame(
    data={"weight": [1 for _ in range(10)], "value": [3 for _ in range(10)]},
    index=["A", "B", "C", "D", "E", "F", "G", "H", "I", "J"],
)
bs = model.new_bool_var_series("b", df.index)  # noqa: F841

# Використання добутку для pandas DataFrame — доволі зручний спосіб
# створювати типові лінійні вирази.
model.add(bs @ df["weight"] <= 100)
model.maximize(bs @ df["value"])
```

Також існує метод `new_constant`, який дозволяє створити змінну зі сталим
значенням. Це дає змогу безпечно замінювати змінні на константи. Це насамперед
корисно для булевих змінних, адже константні цілочисельні змінні в більшості
випадків можна просто замінити звичайними цілими числами.

> [!TIP]
>
> У старому проєкті я помітив, що підтримання тісних меж для цілочисельних
> змінних може суттєво впливати на продуктивність. Використання евристики для
> пошуку прийнятного початкового розв’язку, що дало змогу звузити межі,
> виявилося виправданим, навіть якщо межі були всього на кілька відсотків
> тіснішими. Хоча це було кілька років тому, і CP-SAT значно розвинувся, я й
> досі рекомендую тримати межі значень змінних якомога більш тісними.

У CP-SAT немає неперервних/дійсних змінних (і навіть констант): якщо вам потрібні
дійсні числа, їх треба апроксимувати цілими числами з певною роздільною здатністю.
Наприклад, можна просто помножити всі значення на 100 для кроку 0,01. Значення
2,35 тоді буде представлене як 235. Це, ймовірно, можна було б реалізувати
безпосередньо в CP-SAT, але явна реалізація не складна і має числові наслідки,
про які варто пам’ятати.

Відсутність неперервних змінних може здаватися суттєвим обмеженням, особливо для
тих, хто має досвід у лінійній оптимізації, де неперервні змінні зазвичай
вважаються простішою частиною. Проте, якщо ваша задача містить лише кілька
неперервних змінних, які потрібно апроксимувати великими цілими числами, і
містить складні обмеження, як-от абсолютні значення, тоді як більшість задачі
домінована логічними обмеженнями, CP-SAT часто може перевершити розв’язувачі
змішаного цілочисельного програмування. Лише тоді, коли задача має значну
кількість неперервних змінних і суттєво виграє від сильної лінійної релаксації,
MIP-розв’язувачі матимуть виражену перевагу, попри те, що CP-SAT має пропагатор
на основі двоїстого симплекс-методу.

Я аналізував вплив роздільної здатності (тобто множника, на який множаться
дійсні числа) на час виконання CP-SAT і виявив, що ефект залежить від задачі.
Для однієї задачі час виконання зростав лише логарифмічно з роздільною
здатністю, що дозволило використовувати дуже високу роздільну здатність 100 000x
без значних проблем. Натомість для іншої задачі
час виконання зростав приблизно лінійно з роздільною здатністю, що робило високі
роздільні здатності непрактичними. Час виконання для різних множників у цьому
випадку був таким: 1x: 0,02 с, 10x: 0,7 с, 100x: 7,6 с, 1000x: 75 с, 10 000x:
понад 15 хвилин, хоча розв’язок залишався тим самим, лише масштабованим. Тому,
хоча високі роздільні здатності можуть бути прийнятними для деяких задач у
CP-SAT, важливо перевіряти їхній вплив на час виконання, оскільки він може бути
значним.

З мого досвіду, булеві змінні є критично важливими в багатьох комбінаторних
оптимізаційних задачах. Наприклад, відома задача комівояжера складається лише з
булевих змінних. Тому реалізація розв’язувача, що спеціалізується на булевих
змінних і базується на SAT-розв’язувачі (як CP-SAT), є логічним підходом. CP-SAT
використовує сильні сторони SAT-технік, які дуже ефективні для задач, де
домінують булеві змінні.

Ви можете запитати, чому в CP-SAT потрібно явно задавати імена змінних. Хоча
технічної необхідності для цього, здається, немає, іменування змінних може бути
надзвичайно корисним для налагодження. Розуміння схеми імен дозволяє легше
інтерпретувати внутрішнє представлення моделі і швидше знаходити проблеми. Якщо
чесно, лише кілька разів мені справді доводилося уважно дивитися на внутрішнє
представлення, і в більшості випадків я б волів не витрачати час на іменування
змінних.

<a name="04-modelling-domain-variables"></a>

#### Змінні з користувацьким доменом

Коли ви працюєте з цілочисельними змінними, які, як ви знаєте, можуть набувати
лише певних значень, або хочете обмежити їх можливі значення, змінні з
користувацьким доменом можуть бути цікавими. На відміну від звичайних
цілочисельних змінних, які мають домен у вигляді інтервалу (наприклад, $[1, 100]$),
змінні з доменом можуть задавати конкретний набір значень (наприклад,
$\{1, 31, 57\}$). Це може підвищити ефективність, якщо допустимі значення змінної
суттєво зменшені. Однак це також має недоліки, які ми розглянемо нижче.

CP-SAT працює шляхом перетворення всіх цілочисельних змінних на булеві
(увага: спрощення). Для кожного можливого значення він створює дві булеві
змінні: одна позначає, що цілочисельна змінна дорівнює цьому значенню, а інша
— що вона менша або дорівнює йому. Це називається _order encoding_. На перший
погляд, це може свідчити, що доменні змінні завжди кращі, адже вони зменшують
кількість необхідних булевих змінних.

Однак CP-SAT використовує стратегію лінивого створення цих булевих змінних. Це
означає, що вони генеруються лише за потреби, залежно від процесу прийняття
рішень розв’язувачем. Тому цілочисельна змінна з широким діапазоном — скажімо,
від 0 до 100 — не призведе одразу до створення 200 булевих змінних. Може бути
створено лише кілька, залежно від потреб розв’язувача.

Обмеження домену змінної може мати недоліки. По-перше, якщо припущення щодо
допустимих значень помилкові, це може спричинити тонкі й важковиявні баги. Тому
варто спершу забезпечити коректність, а оптимізації застосовувати вже потім.
По-друге, явне задання домену може суттєво збільшити розмір моделі, адже
розв’язувач має працювати зі списком дискретних значень, а не просто з нижньою
і верхньою межами. Наприклад, якщо змінна має приймати лише парні значення,
неефективно визначати домен, що складається з усіх парних чисел. Краще замінити
змінну $x$ на $2x'$, а в кінцевому розв’язку помножити $x'$ на 2. По-третє, у
деяких випадках використання користувацьких доменів може відкласти знаходження
першого допустимого розв’язку. Оскільки CP-SAT покладається на потужний пошук у
околицях для покращення розв’язків після знаходження першого допустимого, така
затримка може погіршити продуктивність. Якщо обмеження домену не є суттєвою
частиною моделювання, зазвичай краще відкласти його до етапу оптимізації
продуктивності.

Якщо ви все ж вирішите використовувати доменні змінні, ось як їх визначити:

```python
from ortools.sat.python import cp_model

model = cp_model.CpModel()

# Визначаємо домен із вибраних значень
domain = cp_model.Domain.from_values([2, 5, 8, 10, 20, 50, 90])

# Це також можна зробити через інтервали
domain_2 = cp_model.Domain.from_intervals([[8, 12], [14, 20]])

# Доступні деякі операції з доменами
domain_3 = domain.union_with(domain_2)

# Створюємо доменну змінну в межах цього домену
x = model.new_int_var_from_domain(domain, "x")
```

Цей приклад демонструє створення доменної змінної `x`, яка може набувати лише
значень, заданих у `domain`. Це особливо корисно, коли в контексті задачі
змінні мають сенс лише в обмеженому наборі значень.

<a name="04-modelling-objectives"></a>

### Цілі

Не кожна задача потребує цілі; іноді достатньо знайти допустимий розв’язок.
CP-SAT відмінно знаходить допустимі розв’язки — це те, де MIP-розв’язувачі часто
працюють гірше. Водночас CP-SAT також здатен ефективно оптимізувати, що є
слабким місцем для старіших CP-розв’язувачів, якщо судити з мого досвіду.

CP-SAT дозволяє мінімізувати або максимізувати лінійний вираз. Складніші вирази
можна змоделювати за допомогою допоміжних змінних і додаткових обмежень. Щоб
задати цільову функцію, використовуйте `model.minimize` або `model.maximize` з
лінійним виразом. Така гнучкість робить CP-SAT надійним інструментом для
різноманітних оптимізаційних задач.

```python
# Базова модель зі змінними та обмеженнями
model = cp_model.CpModel()
x = model.new_int_var(-100, 100, "x")
y = model.new_int_var(-100, 100, "y")
model.add(x + 10 * y <= 100)

# Мінімізуємо 30x + 50y
model.maximize(30 * x + 50 * y)
```

Подивімося, як моделювати складніші вирази, використовуючи булеві змінні та
генератори.

```python
model = cp_model.CpModel()
x_vars = [model.new_bool_var(f"x{i}") for i in range(10)]
model.minimize(sum(i * x_vars[i] if i % 2 == 0 else i * ~x_vars[i] for i in range(10)))
```

Ця ціль дорівнює

```math
\min \sum_{i=0}^{9} i\cdot x_i \text{ якщо } i \text{ парне, інакше } i\cdot \neg x_i
```

Щоб реалізувати
[лексикографічну оптимізацію](https://en.wikipedia.org/wiki/Lexicographic_optimization),
можна робити кілька раундів, кожного разу фіксуючи попередню ціль як обмеження.

```python
# базова модель
model = cp_model.CpModel()
x = model.new_int_var(-100, 100, "x")
y = model.new_int_var(-100, 100, "y")
z = model.new_int_var(-100, 100, "z")
model.add(x + 10 * y - 2 * z <= 100)

# Визначаємо цілі
first_objective = 30 * x + 50 * y
second_objective = 10 * x + 20 * y + 30 * z

# Оптимізуємо першу ціль
model.maximize(first_objective)
solver = cp_model.CpSolver()
solver.solve(model)

# Фіксуємо першу ціль і оптимізуємо другу
model.add(first_objective == int(solver.objective_value))  # фіксуємо попередню ціль
model.minimize(second_objective)  # оптимізуємо другу ціль
solver.solve(model)
```

> [!TIP]
>
> Більш ефективну реалізацію лексикографічної оптимізації можна знайти в
> розділі _Coding Patterns_.

Щоб працювати з нелінійними цілями в CP-SAT, використовуйте допоміжні змінні та
обмеження. Наприклад, щоб включити абсолютне значення змінної в ціль, спершу
створіть нову змінну, яка представляє це абсолютне значення. Незабаром ми
детальніше розглянемо, як задавати такі обмеження. Нижче — приклад того, як
змоделювати та мінімізувати абсолютне значення змінної `x`:

```python
# Припустимо, x вже визначено в моделі
abs_x = model.new_int_var(
    0, 100, "|x|"
)  # Створюємо змінну, що представляє абсолютне значення x
model.add_abs_equality(target=abs_x, expr=x)  # Визначаємо abs_x як |x|
model.minimize(abs_x)  # Мінімізуємо abs_x
```

Обмеження, доступні для визначення допустимої області розв’язків, обговорюються
в наступному розділі.

<a name="04-modelling-linear-constraints"></a>

### Лінійні обмеження

Це класичні обмеження, які використовуються і в лінійній оптимізації. Пам’ятайте,
що ви все ще не можете використовувати дійсні числа. Як і в лінійній оптимізації,
не дозволено множити змінну на щось, окрім константи, і не можна застосовувати
інші математичні операції.

```python
model.add(10 * x + 15 * y <= 10)
model.add(x + z == 2 * y)

# Це насправді не лінійне, але все одно працює.
model.add(x + y != z)

# Оскільки ми працюємо з цілими числами, строгі нерівності легко реалізувати:
# x < z еквівалентне x <= z-1
model.add(x < y + z)
model.add(y > 300 - 4 * z)
```

Зверніть увагу, що `!=` може бути повільнішим за інші (`<=`, `>=`, `==`)
обмеження, адже це не лінійне обмеження. Якщо у вас є набір змінних, які
взаємно не дорівнюють (`!=`), краще використати `all_different` (див. нижче),
ніж явні `!=` обмеження.

> [!WARNING]
>
> Якщо ви використовуєте перетинні лінійні обмеження, можуть виникати проблеми,
> бо точка перетину повинна бути цілою. Тут немає поняття допуску допустимості,
> як у MIP-розв’язувачах, де дозволяються невеликі відхилення. Допуск у MIP
> дозволяє, наприклад, вважати 0,763445 == 0,763439 через числові похибки
> плаваючої арифметики. У CP-SAT потрібно, щоб значення збігалися точно.

Розгляньмо приклад із двома лінійними рівностями:

```math
x - y = 0
```

```math
4-x = 2y
```

```math
x, y \geq 0
```

Можна перевірити, що $x=4/3$ і $y=4/3$ — допустимий розв’язок. Однак кодування
цього в CP-SAT призводить до недопустимої моделі:

```python
model = cp_model.CpModel()
x = model.new_int_var(-100, 100, "x")
y = model.new_int_var(-100, 100, "y")

model.add(x - y == 0)
model.add(4 - x == 2 * y)

solver = cp_model.CpSolver()
status = solver.solve(model)
assert status == cp_model.INFEASIBLE
```

Навіть масштабування, наприклад множення змінних на 1 000 000 для підвищення
роздільної здатності, не зробить модель допустимою. Хоча типові LP-розв’язувачі
опрацювали б цю модель без проблем, CP-SAT має труднощі, якщо не усунути дроби,
наприклад, помноживши всі члени на 3. Це вимагає ручного втручання, що суперечить
ідеї використання розв’язувача. Такі обмеження важливо враховувати, хоча вони
рідко трапляються в практичних застосуваннях.

> [!TIP]
>
> Якщо у вас довгі суми змінних із коефіцієнтами, може бути ефективніше
> використовувати методи sum у LinearExpr, ніж Python-функцію sum. Зверніть
> увагу, що ця функція зараз не підтримує генератори.
>
> ```python
> xs = [model.new_int_var(0, 10, f"x{i}") for i in range(5)]
> weights = [i for i in range(5)]
> model.add(cp_model.LinearExpr.sum(xs) >= 1)
> model.minimize(cp_model.LinearExpr.weighted_sum(xs, weights))
> ```

Якщо у вас є нижня та верхня межі для лінійного виразу, можна використати метод
`add_linear_constraint`, який дозволяє задати обидві межі одразу.

```python
model.add_linear_constraint(linear_expr=10 * x + 15 * y, lb=-100, ub=10)
```

Схожий за назвою метод `AddLinearExpressionInDomain` розглянуто пізніше.

<a name="04-modelling-logic-constraints"></a>

### Логічні обмеження (пропозиційна логіка)

Пропозиційна логіка дозволяє описувати взаємозв’язки між істинними або хибними
твердженнями за допомогою логічних операторів. Розгляньмо простий сценарій, де
ми визначаємо три булеві змінні:

```python
b1 = model.new_bool_var("b1")
b2 = model.new_bool_var("b2")
b3 = model.new_bool_var("b3")
```

Ці змінні `b1`, `b2` і `b3` представляють окремі пропозиції, істинні значення
яких мають бути визначені моделлю.

Отримати заперечення булевої змінної можна через `~` або метод `.Not()`. Отриману
змінну можна використовувати так само, як і оригінальну:

```python
not_b1 = ~b1  # Заперечення b1
not_b2 = b2.Not()  # Альтернативний запис заперечення
```

Зверніть увагу: у всіх наведених прикладах можна використовувати більше ніж
три змінні, окрім `add_implication`, яке визначене лише для двох змінних.

> [!WARNING]
>
> Булеві змінні — це фактично спеціальні цілочисельні змінні з доменом 0 і 1.
> Тому їх можна включати в лінійні обмеження. Водночас цілочисельні змінні, на
> відміну від булевих, не можна використовувати в булевих обмеженнях. Це
> відрізняється від деяких мов програмування, як-от Python, де цілі числа
> іноді можуть замінювати булеві.

#### Додавання логічних OR-обмежень

Операція логічного OR гарантує, що принаймні одна з умов істинна. Для цього
можна використати:

```python
model.add_bool_or(b1, b2, b3)  # b1 або b2 або b3 має бути істинним
model.add_at_least_one([b1, b2, b3])  # Альтернативний запис
model.add(b1 + b2 + b3 >= 1)  # Альтернатива як лінійне обмеження
```

Усі рядки гарантують, що принаймні одна з `b1`, `b2`, `b3` істинна.

#### Додавання логічних AND-обмежень

Логічне AND вимагає, щоб усі умови були істинними одночасно. Щоб змоделювати
умови, де `b1` істинна, а `b2` і `b3` — хибні, можна використати:

```python
model.add_bool_and(b1, b2.Not(), b3.Not())  # b1 і не b2 і не b3 мають бути істинними
model.add_bool_and(b1, ~b2, ~b3)  # Альтернативний запис із '~'
```

Метод `add_bool_and` найефективніше використовувати разом з `only_enforce_if`
(див. [Умовні обмеження (реїфікація)](#04-modelling-conditional-constraints)).
У випадках без `only_enforce_if` проста AND-умова
$\left( b_1 \land \neg b_2 \land \neg b_3 \right)$ стає зайвою, якщо
підставити $b_1 = 1$ та $b_2, b_3 = 0$. У простих сценаріях варто замінювати
ці змінні константами, щоб зменшити зайву складність, особливо у великих моделях.
У невеликих моделях CP-SAT ефективно обробляє такі надлишковості, тож можна
зосередитися на зрозумілості й читабельності моделі.

#### Додавання логічних XOR-обмежень

Операція XOR (виключне OR) гарантує, що істинна непарна кількість операндів.
Важливо правильно розуміти це визначення, особливо для більш ніж двох змінних:

- Для двох змінних, наприклад `b1 XOR b2`, операція істинна, якщо істинна рівно
  одна з цих змінних, що збігається з обмеженням «рівно одна» для цього випадку.
- Для трьох і більше змінних, наприклад `b1 XOR b2 XOR b3`, операція істинна,
  якщо непарна кількість змінних істинна (тобто одна або три, якщо змінних три).

Ця властивість XOR може бути неочевидною, але вона важлива для моделювання
сценаріїв, де кількість істинних умов має бути непарною:

```python
model.add_bool_xor(b1, b2)  # Істинно, якщо рівно одна з b1 або b2 істинна
model.add_bool_xor(
    b1, b2, b3
)  # Істинно, якщо непарна кількість b1, b2, b3 істинна (тобто 1 або 3)
```

#### Задання унікальних умов

Щоб задати, що істинна рівно одна або не більше ніж одна змінна, використовуйте:

```python
model.add_exactly_one([b1, b2, b3])  # Рівно одна змінна істинна
model.add_at_most_one([b1, b2, b3])  # Не більше ніж одна змінна істинна
```

Ці обмеження корисні для сценаріїв, де потрібно змоделювати взаємовиключні
вибори.

Альтернативно можна використати `add`:

```python
model.add(b1 + b2 + b3 == 1)  # Рівно одна змінна істинна
model.add(b1 + b2 + b3 <= 1)  # Не більше ніж одна змінна істинна
```

#### Моделювання імплікацій

Логічна імплікація `->` означає, що якщо перша умова істинна, то друга теж має
бути істинною. Це можна змоделювати так:

```python
model.add_implication(b1, b2)  # Якщо b1 істинна, то b2 теж має бути істинною
```

Також можна використати `add`:

```python
model.add(b2 >= b1)  # Якщо b1 істинна, то b2 теж має бути істинною
```

#### Еквівалентні перетворення логічних виразів

Логічні вирази часто записують у вкладеній формі, але CP-SAT потребує
плоскої структури. На щастя, будь-який вираз пропозиційної логіки можна
переписати у плоску структуру, яка використовує лише `and_bool_or`
(також відому як кон’юнктивна нормальна форма, CNF). Усі інші обмеження —
це лише синтаксичний цукор для більш природного моделювання. Хоча CP-SAT
було б легко підтримувати вкладені вирази, розробка фокусується на рушії, а
не на інтерфейсі. Тому наразі такі перетворення треба виконувати вручну
(або використовувати [CPMpy](https://cpmpy.readthedocs.io/en/latest/index.html)).

Найкорисніші перетворення:

1. Імплікація: `A -> B` еквівалентна `NOT A OR B`
2. `NOT (A AND B)` еквівалентне `NOT A OR NOT B` (закон де Моргана 1)
3. `NOT (A OR B)` еквівалентне `NOT A AND NOT B` (закон де Моргана 2)

Ці еквівалентності можна перевірити таблицею істинності. Оскільки є лише чотири
можливі комбінації істинності для `A` і `B`, достатньо перевірити, що обидві
колонки дають однакові результати:

| A   | B   | A -> B | NOT A OR B |
| --- | --- | ------ | ---------- |
| 0   | 0   | 1      | 1          |
| 0   | 1   | 1      | 1          |
| 1   | 0   | 0      | 0          |
| 1   | 1   | 1      | 1          |

Зауважте, що `A` і `B` можуть бути логічними виразами, а не лише окремими
змінними. Більш розширений список еквівалентностей можна знайти на
[Wikipedia](https://en.wikipedia.org/wiki/Propositional_logic#List_of_classically_valid_argument_forms).

> :video:
>
> Логіка — типова бакалаврська дисципліна, і в мережі є записані курси на
> випадок, якщо хочете освіжити знання:
>
> - [Logic 101](https://www.youtube.com/playlist?list=PLKI1h_nAkaQq5MDWlKXu0jeZmLDt-51on)
>   від William Spaniel — серія коротких відео з основ логіки, також підходить
>   для людей без глибокої математичної підготовки.
> - [Logic Stanford CS221](https://youtube.com/playlist?list=PLh7QmcIRQB-uiOS4GMlBbq0jkvtqhqtq0&si=dyXebJW-nvW14pFp)
>   має більш виражений фокус на інформатиці і теж доволі компактний — легко
>   переглянути за день.

> :reference:
>
> Також дуже рекомендую наступний
> [розділ](<https://eng.libretexts.org/Bookshelves/Computer_Science/Programming_and_Computation_Fundamentals/Mathematics_for_Computer_Science_(Lehman_Leighton_and_Meyer)/01:_Proofs/03:_Logical_Formulas>)
> відкритої книги _Mathematics for Computer Science_ авторів Lehman,
> Leighton і Meyer. Читається швидко і містить усі важливі еквівалентності.

Розгляньмо кілька прикладів:

1. Щоб змоделювати `b1 -> b2`, використовуйте `model.add_implication(b1, b2)`.
   Альтернативно перепишіть як `NOT b1 OR b2` і використайте
   `model.add_bool_or(~b1, b2)`.
2. Щоб змоделювати `NOT (b1 AND b2)`, перепишіть як `NOT b1 OR NOT b2` і
   використайте `model.add_bool_or(~b1, ~b2)`.
3. Щоб змоделювати `NOT (b1 OR b2)`, перепишіть як `NOT b1 AND NOT b2` і
   використайте `model.add_bool_and(~b1, ~b2)`. (Ще ефективніше — безпосередньо
   підставити `b1` і `b2` як 0, адже вони не можуть бути істинними.)
4. Щоб змоделювати `(b1 AND b2) -> b3`, перепишіть як `NOT (b1 AND b2) OR b3`,
   що еквівалентно `(NOT b1 OR NOT b2) OR b3`. Тоді використайте
   `model.add_bool_or(~b1, ~b2, b3)`.
5. Щоб змоделювати `(b1 OR b2) -> b3`, перепишіть як `(b1 -> b3) AND (b2 -> b3)`,
   що еквівалентно `(NOT b1 OR b3) AND (NOT b2 OR b3)`. Тоді використайте:
   ```python
   model.add_bool_or(~b1, b3)
   model.add_bool_or(~b2, b3)
   ```
6. Щоб змоделювати `b1 -> (b2 OR b3)`, перепишіть як `NOT b1 OR (b2 OR b3)`,
   що еквівалентно `NOT b1 OR b2 OR b3`. Тоді використайте
   `model.add_bool_or(~b1, b2, b3)`.
7. Вирази виду `(b1 AND b2) OR (b3 AND b4)` можна переписати за дистрибутивними
   законами у
   `(b1 OR b3) AND (b1 OR b4) AND (b2 OR b3) AND (b2 OR b4)`. Однак для довших
   виразів це може призводити до експоненційного зростання кількості клауз.
   У таких випадках часто ефективніше вводити допоміжні змінні за допомогою
   [перетворення Тсейтіна](https://en.wikipedia.org/wiki/Tseytin_transformation).

> [!WARNING]
>
> Розуміння цих еквівалентностей допомагає моделювати складні логічні вирази і
> в деяких випадках покращувати продуктивність, замінюючи дорогі конструкції на
> простіші (короткі `add_bool_or` клаузи зазвичай найефективніші; довжина 2 —
> тривіальна для пропагації CP-SAT). Водночас CP-SAT виконує багато
> перетворень автоматично. Наприклад, `add_implication` напряму перетворюється
> у `add_bool_or` всередині
> [(див. вихідний код)](https://github.com/google/or-tools/blob/7ee639cf6981a9beeba908cf543a50f4ee7413ad/ortools/sat/cp_model.h#L807).
> Також існують складніші автоматичні перетворення, які точно не варто робити
> вручну. Див. розділ
> [Preprocessing in SAT Solving](https://cca.informatik.uni-freiburg.de/papers/BiereJarvisaloKiesl-SAT-Handbook-2021-Preprocessing-Chapter-Manuscript.pdf),
> якщо цікавлять деталі. Як завжди, спершу пріоритет — коректність, а вже потім
> продуктивність.

<a name="04-modelling-conditional-constraints"></a>

### Умовні обмеження (реїфікація)

У практичних застосуваннях часто виникають сценарії, коли умови визначають
застосування певних обмежень. Наприклад, «якщо ця умова істинна, тоді має
застосуватися конкретне обмеження» або «якщо обмеження порушене, встановити
штрафну змінну, що активує інше обмеження». Крім того, реальні обмеження іноді
можна обійти фінансовими або іншими поступками, наприклад орендувати дорожчу
вантажівку, щоб перевищити ліміт, або дозволити працівнику відпочити після
подвійної зміни.

> У програмуванні з обмеженнями **реїфікація** — це пов’язування булевої змінної
> з обмеженням, щоб зафіксувати його істинність і перетворити задоволення
> обмеження на змінну, яку можна використовувати в інших обмеженнях. Повна
> реїфікація пов’язує булеву змінну так, що вона `True`, якщо обмеження
> задоволене, і `False` — інакше, що дозволяє безпосередньо використовувати цю
> змінну в інших рішеннях або обмеженнях. Натомість половинна реїфікація або
> імпліковані обмеження встановлює односторонній зв’язок, коли `True` для
> булевої змінної означає, що обмеження має виконуватися, але `False` не дає
> інформації про задоволення обмеження. Це особливо корисно для вираження
> складної умовної логіки та моделювання сценаріїв, де треба явно обробляти лише
> задоволення, а не порушення обмеження.

Для ефективної роботи з такими умовними сценаріями CP-SAT має метод
`only_enforce_if` для лінійних і деяких булевих обмежень, який активує
обмеження лише за виконання певної умови. Цей метод зазвичай ефективніший за
класичні підходи на кшталт
[методу Big-M](https://en.wikipedia.org/wiki/Big_M_method) і спрощує модель,
усуваючи потребу підбирати значення Big-M.

```python
# Значення вантажу, який потрібно перевезти
load_value = model.new_int_var(0, 100, "load_value")

# ... деяка логіка, що визначає значення вантажу ...

# Змінні для вибору вантажівки
truck_a = model.new_bool_var("truck_a")
truck_b = model.new_bool_var("truck_b")
truck_c = model.new_bool_var("truck_c")

# Орендуємо лише одну вантажівку
model.add_at_most_one([truck_a, truck_b, truck_c])

# Залежно від вибору вантажівки, обмежуємо вантаж
model.add(load_value <= 50).only_enforce_if(truck_a)
model.add(load_value <= 80).only_enforce_if(truck_b)
model.add(load_value <= 100).only_enforce_if(truck_c)

# Додаткова логіка
driver_has_big_truck_license = model.new_bool_var("driver_has_big_truck_license")
driver_has_special_license = model.new_bool_var("driver_has_special_license")
# Лише водії з великою ліцензією або спеціальною можуть орендувати truck_c
model.add_bool_or(
  driver_has_big_truck_license, driver_has_special_license
).only_enforce_if(truck_c)

# Мінімізуємо вартість оренди
model.minimize(30 * truck_a + 40 * truck_b + 80 * truck_c)
```

У `only_enforce_if` можна використовувати заперечення:

```python
model.add(x + y == 10).only_enforce_if(~b1)
```

Також можна передати список булевих змінних, і тоді обмеження буде
застосовано лише тоді, коли всі змінні зі списку істинні.

```python
model.add(x + y == 10).only_enforce_if([b1, ~b2])  # застосувати лише якщо b1 І НЕ b2
```

> [!WARNING]
>
> Хоча `only_enforce_if` у CP-SAT часто ефективніший за аналогічні концепції в
> класичних MIP-розв’язувачах, він усе одно може суттєво впливати на
> продуктивність CP-SAT. Виконавши додаткові міркування, часто можна знайти
> ефективніший спосіб змоделювати задачу без використання `only_enforce_if`;
> див. попередній розділ про логічні обмеження. Оскільки `only_enforce_if`
> часто є більш природним способом моделювання, його варто застосувати для
> першого прототипу, а про «розумніші» способи подумати згодом.

<a name="04-modelling-absmaxmin"></a>

### Абсолютні значення та функції максимуму/мінімуму з цілочисельними змінними

Працюючи з цілочисельними змінними в CP-SAT, операції на кшталт абсолютного
значення, максимуму й мінімуму не можна напряму виразити за допомогою базових
Python-операцій `abs`, `max` чи `min`. Натомість потрібно використовувати
допоміжні змінні та спеціальні обмеження, що зв’язують ці змінні з потрібними
значеннями. Потім допоміжні змінні можна використовувати в інших обмеженнях,
представляючи бажаний підвираз.

```python
model = cp_model.CpModel()
x = model.new_int_var(-100, 100, "x")
y = model.new_int_var(-100, 100, "y")
z = model.new_int_var(-100, 100, "z")

# Допоміжна змінна для абсолютного значення x+z
abs_xz = model.new_int_var(0, 200, "|x+z|")
model.add_abs_equality(target=abs_xz, expr=x + z)

# Змінні для максимуму та мінімуму x, (y-1) і z
max_xyz = model.new_int_var(0, 100, "max(x, y-1, z)")
# Зміна в ortools 9.15: було add_max_equality(target=max_xyz, exprs=[x, y - 1, z])
model.add_max_equality(max_xyz, x, y - 1, z)

min_xyz = model.new_int_var(-100, 100, "min(x, y-1, z)")
# Зміна в ortools 9.15: було add_min_equality(target=min_xyz, exprs=[x, y - 1, z])
model.add_min_equality(min_xyz, x, y - 1, z)
```

Хоча деякі практики повідомляють, що ці методи ефективніші за аналоги в
класичних MIP-розв’язувачах, такі висновки здебільшого ґрунтуються на
емпіричних спостереженнях у конкретних сценаріях. Варто також пам’ятати, що
доволі часто ці обмеження можна замінити більш ефективними лінійними
обмеженнями. Ось приклад більш ефективного моделювання максимуму:

```python
x = model.new_int_var(0, 100, "x")
y = model.new_int_var(0, 100, "y")
z = model.new_int_var(0, 100, "z")

# Забезпечуємо, що max_xyz не менше максимуму з x, y, z
max_xyz = model.new_int_var(0, 100, "max_xyz")
model.add(max_xyz >= x)
model.add(max_xyz >= y)
model.add(max_xyz >= z)

# Мінімізуємо max_xyz, щоб він точно дорівнював максимуму
model.minimize(max_xyz)
```

Такий підхід використовує мінімізацію для «затягування» межі, завдяки чому
`max_xyz` точно відображає максимум із `x`, `y` і `z`. Використання лінійних
обмежень часто дає швидше розв’язання порівняно з `add_max_equality`. Подібні
техніки існують і для абсолютних значень, мінімумів та складних сценаріїв, де
пряме забезпечення рівності через цільову функцію неможливе.

<a name="04-modelling-multdivmod"></a>

### Множення, ділення і модуль

У практичних задачах може знадобитися виконувати складніші арифметичні операції,
ніж просто додавання. Наприклад, орендна вартість вантажівок може обчислюватися
як добуток кількості вантажівок, кількості днів і добової ставки. Тут перші два
множники — змінні, тож вираз квадратичний. Спроба напряму перемножити дві
змінні в CP-SAT дасть помилку, адже метод `add` приймає лише лінійні вирази.
Втім, CP-SAT підтримує множення, ділення та модульні операції. Як і з `abs`,
`max` і `min`, потрібно створити допоміжну змінну, що представляє результат.

```python
model = cp_model.CpModel()
x = model.new_int_var(-100, 100, "x")
y = model.new_int_var(-100, 100, "y")
z = model.new_int_var(-100, 100, "z")

xyz = model.new_int_var(-(100**3), 100**3, "x*y*z")
model.add_multiplication_equality(xyz, [x, y, z])  # xyz = x*y*z

model.add_modulo_equality(x, y, 3)  # x = y % 3
model.add_division_equality(x, y, z)  # x = y // z
```

Під час використання цих операцій ви часто переходите від лінійної до нелінійної
оптимізації, що загалом складніше. У випадку ділення важливо пам’ятати, що
операції цілочисельні: `5 // 2` дорівнює `2`, а не `2.5`.

Багато задач спочатку містять нелінійні вирази, які часто можна переформулювати
або апроксимувати лінійними. Це може зробити задачу легшою для розв’язання та
прискорити її. Хоча важливо моделювати задачу якомога ближче до реальності, не
менш важливо балансувати точність і розв’язуваність. Надто точна модель марна,
якщо розв’язувач не здатен ефективно її оптимізувати. Може бути корисно
застосовувати кілька фаз оптимізації — почати з простішої, менш точної моделі,
а потім поступово її уточнювати.

Деякі нелінійні вирази все ще можна ефективно обробляти, якщо вони опуклі.
Наприклад, обмеження другого порядку (second-order cone) можна розв’язувати
за поліноміальний час методами внутрішніх точок. Gurobi, наприклад, підтримує
такі обмеження нативно. CP-SAT має LP-пропагатор, але він спирається на метод
Dual Simplex, який для таких обмежень не підходить, і змушений використовувати
простішi методи. Аналогічно, більшість open-source MIP-розв’язувачів теж мають
труднощі з цими обмеженнями.

Складно визначити, чи зможе CP-SAT ефективно впоратися з нелінійними виразами,
або який розв’язувач найкраще підходить для вашої задачі. Нелінійні вирази
завжди складні, тому їх варто уникати, якщо можливо.

Ось один із улюблених прикладів моїх студентів про нелінійний вираз, якого
можна уникнути. Коли вони вперше знайомляться з нотацією
$\sum_{e \in E} cost(e)\cdot x_e$, і якщо термін залежить від комбінації двох
бінарних змінних, вони часто використовують квадратний вираз
$\sum_{e,e'\in E} concost(e, e')\cdot x_e\cdot x_{e'}$. Однак такі випадки
часто можна змоделювати лінійно через допоміжну змінну, уникнувши складнощів
нелінійного моделювання.

```python
model = cp_model.CpModel()

b1 = model.new_bool_var("b1")
b2 = model.new_bool_var("b2")

b1b2 = model.new_bool_var("b1b2")
model.add_implication(~b1, ~b1b2)
model.add_implication(~b2, ~b1b2)
model.add_bool_or(~b1, ~b2, b1b2)  # опційно, для штрафного терміна в цілі.
```

Існує багато інших випадків, коли нелінійні вирази можна спростити за допомогою
допоміжних змінних або перенесення нелінійних компонентів у константи. Однак
вивчення цих технік найкорисніше, коли ви стикаєтеся з конкретними труднощами
у ваших моделях.

Далі ми повернемося до нелінійних виразів і їхнього перетворення на кусочно-
лінійні апроксимації. Це дасть базове розуміння, необхідне для більш складних
сценаріїв моделювання.

<a name="04-modelling-alldifferent"></a>

### All Different

У багатьох задачах призначення та планування важливо, щоб усі змінні мали
різні значення. Наприклад, у призначенні частот жодні два передавачі в одній
зоні не повинні працювати на однаковій частоті, або в розкладі жодні дві задачі
не повинні займати один і той самий слот. Зазвичай цю вимогу можна змоделювати
квадратичною кількістю нерівностей (`!=`). Однак більш елегантне рішення —
використати обмеження `add_all_different`, яке безпосередньо забезпечує, що всі
змінні в списку мають унікальні значення. Це обмеження особливо корисне при
розв’язанні судоку чи
[задачі N-ферзів](https://developers.google.com/optimization/cp/queens).

```python
model = cp_model.CpModel()
x = model.new_int_var(-100, 100, "x")
y = model.new_int_var(-100, 100, "y")
z = model.new_int_var(-100, 100, "z")

# Додаємо обмеження all-different
model.add_all_different([x, y, z])

# Просунуте використання з перетвореннями
vars = [model.new_int_var(0, 10, f"v_{i}") for i in range(10)]
model.add_all_different([x + i for i, x in enumerate(vars)])
```

Використання `add_all_different` не лише спрощує моделювання, але й задіює
спеціалізований доменний пропагатор у CP-SAT, що підвищує ефективність порівняно
з багатьма `!=` обмеженнями. Однак якщо ви змішуєте `!=` з `add_all_different`,
будьте обережні: CP-SAT вимикає автоматичне виведення `add_all_different` з
груп `!=` обмежень, і це може погіршити продуктивність.

Для практичної демонстрації дивіться
[приклад задачі розфарбування графа](https://github.com/d-krupke/cpsat-primer/blob/main/examples/add_all_different.ipynb)
у репозиторії. Там `!=` обмеження розв’язали задачу за секунди, тоді як
`add_all_different` зайняло значно більше часу, що ілюструє важливість вибору
методу залежно від масштабу і складності задачі.

Альтернативно можна моделювати булевими змінними з обмеженнями типу
`add_at_most_one` або попарними запереченнями (`add_boolean_or(~b1, ~b2)`).
Такий підхід виграє від ефективної обробки булевої логіки в CP-SAT і дозволяє
легко інтегрувати додаткові обмеження або цілі, наприклад ліцензійні витрати
для певних частот. Хоча CP-SAT робить щось подібне всередині, він створює ці
конструкції ліниво й лише за потреби, тоді як явне моделювання в Python може
бути менш ефективним.

Вибір між цими методами — або іншим підходом — залежить від конкретних вимог
моделі й розуміння поведінки CP-SAT. Якщо сумніваєтеся, почніть із найбільш
інтуїтивного методу й коригуйте підхід на основі спостережень за
продуктивністю.

<a name="04-modelling-table"></a>

### Домени та комбінації

Під час оптимізації сценаріїв із наперед визначеними допустимими значеннями або
комбінаціями змінних — часто заданими у таблиці — корисно безпосередньо
обмежувати домен виразу або набору змінних.

Розгляньмо приклад оптимізації графіка змін для команди працівників, де є
таблиця допустимих комбінацій для кожної зміни:

| Працівник 1 | Працівник 2 | Працівник 3 | Працівник 4 |
| ---------- | ---------- | ---------- | ---------- |
| 1          | 0          | 1          | 0          |
| 0          | 1          | 1          | 0          |
| 1          | 0          | 0          | 1          |
| 0          | 1          | 0          | 1          |

У CP-SAT це можна ефективно змоделювати за допомогою `add_allowed_assignments`:

```python
model = cp_model.CpModel()
x_employee_1 = model.new_bool_var("x_employee_1")
x_employee_2 = model.new_bool_var("x_employee_2")
x_employee_3 = model.new_bool_var("x_employee_3")
x_employee_4 = model.new_bool_var("x_employee_4")

# Визначаємо дозволені призначення
allowed_assignments = [
    [1, 0, 1, 0],
    [0, 1, 1, 0],
    [1, 0, 0, 1],
    [0, 1, 0, 1],
]

model.add_allowed_assignments(
    [x_employee_1, x_employee_2, x_employee_3, x_employee_4], allowed_assignments
)
```

Альтернативно, заборонені комбінації можна вказати через
`add_forbidden_assignments`:

```python
prohibit_assignments = [
    [1, 0, 1, 0],
    [0, 1, 1, 0],
    [1, 0, 0, 1],
    [0, 1, 0, 1],
]
model.add_forbidden_assignments(
    [x_employee_1, x_employee_2, x_employee_3, x_employee_4], prohibit_assignments
)
```

Користь `add_allowed_assignments` найбільш помітна тоді, коли його
поєднують з іншими обмеженнями в моделі, а не коли він охоплює всі змінні. Якщо
таблиця охоплювала б усі змінні, теоретично можна було б просто перебрати рядки
та знайти найкраще рішення без складних оптимізаційних технік. Однак
розгляньмо сценарій, де обмеження інтегруються між різними змінами:

```python
NUM_SHIFTS = 7

model = cp_model.CpModel()
x_employee_1 = [model.new_bool_var(f"x_employee_1_{i}") for i in range(NUM_SHIFTS)]
x_employee_2 = [model.new_bool_var(f"x_employee_2_{i}") for i in range(NUM_SHIFTS)]
x_employee_3 = [model.new_bool_var(f"x_employee_3_{i}") for i in range(NUM_SHIFTS)]
x_employee_4 = [model.new_bool_var(f"x_employee_4_{i}") for i in range(NUM_SHIFTS)]

for i in range(NUM_SHIFTS):
    model.add_allowed_assignments(
        [x_employee_1[i], x_employee_2[i], x_employee_3[i], x_employee_4[i]],
        allowed_assignments,
    )

# ... деякі додаткові обмеження та цілі, що пов’язують дні ...
# ... якби дні були незалежні, ви б розв’язували кожен день окремо ...
```

Метод `add_allowed_assignments` у CP-SAT дозволяє безпосередньо включати
конкретні допустимі комбінації в модель оптимізації, гарантує, що в просторі
розв’язків розглядаються лише дозволені конфігурації. Метод фактично
«зашиває» ці конфігурації, спрощуючи модель шляхом попереднього визначення
допустимих комбінацій змінних, подібно до правил для змін персоналу чи
розподілу ресурсів.

> [!NOTE]
>
> Жорстке кодування конкретних комбінацій у моделі — це попередній крок до
> просунутих технік декомпозиції на кшталт декомпозиції Данцига–Вулфа. У цьому
> методі складну оптимізаційну задачу спрощують, замінюючи групу корельованих
> змінних складовими змінними. Така складова змінна представляє розв’язок
> підзадачі. Оптимізація цих складових змінних у майстер-задачі істотно зменшує
> складність моделі та підвищує ефективність розв’язання великомасштабних задач.

Схожий метод для керування лінійними виразами (а не прямими призначеннями) —
`add_linear_expression_in_domain`. Припустимо, що певний лінійний вираз,
\(10x + 5y\), має дорівнювати 20, 50 або 100:

```python
model = cp_model.CpModel()
x = model.new_int_var(-100, 100, "x")
y = model.new_int_var(-100, 100, "y")

domain = cp_model.Domain.from_values([20, 50, 100])
model.add_linear_expression_in_domain(10 * x + 5 * y, domain)
```

> [!WARNING]
>
> Переконайтеся, що обчислення коректні, особливо при роботі з цілими числами,
> щоб не створити недопустиму або надто жорстку модель. Розгляньте варіант
> використання допоміжної змінної з обмеженим доменом і м’якшими обмеженнями
> (`<=`, `>=`), щоб отримати більш гнучку постановку.

<a name="04-modelling-element"></a> <a name="04-modelling-array"></a>

### Обмеження елементів/масивів

Перш ніж перейти до спеціалізованих обмежень, розгляньмо останнє загальне.
Обмеження елемента дозволяє звертатися до значення змінної (або з ortools 9.12 —
до лінійного виразу) в масиві, використовуючи іншу змінну як індекс. Звернення
до елемента масиву з константним індексом тривіальне; натомість індекс як
змінна додає складності. Це обмеження також можна використати, щоб змусити
змінну дорівнювати значенню в певній позиції масиву.

```python
model = cp_model.CpModel()
x = model.new_int_var(-100, 100, "x")
y = model.new_int_var(-100, 100, "y")
z = model.new_int_var(-100, 100, "z")
var_array = [x, y, z]

# Змінна для індексу та змінна для значення за цим індексом.
index_var = model.new_int_var(0, len(var_array) - 1, "index")
value_at_index_var = model.new_int_var(-100, 100, "value_at_index")

# Застосовуємо обмеження елемента, щоб зв’язати індекс і значення.
model.add_element(expressions=var_array, index=index_var, target=value_at_index_var)
# УВАГА: до ortools 9.12 було `variables=` замість `expressions=`.
```

Приклади допустимих призначень:

| `x` | `y` | `z` | `index_var` | `value_at_index` |
| --- | --- | --- | ----------- | ---------------- |
| 3   | 4   | 5   | 0           | 3                |
| 3   | 4   | 5   | 1           | 4                |
| 3   | 4   | 5   | 2           | 5                |
| 7   | 3   | 4   | 0           | 7                |

Наступне обмеження нагадує стабільне зіставлення у вигляді масивів. Для двох
масивів змінних $v$ і $w$ однакової довжини $|v|$ воно накладає бієктивний
зв’язок: $v[i]=j \Leftrightarrow w[j]=i$ для всіх
$i,j \in 0,\ldots,|v|-1$. Це обмеження обмежує значення змінних до
$0,\ldots, |v|-1$.

```python
model = cp_model.CpModel()
v = [model.new_int_var(0, 5, f"v_{i}") for i in range(6)]
w = [model.new_int_var(0, 5, f"w_{i}") for i in range(6)]

model.add_inverse(v, w)
```

Приклади допустимих призначень:

| масив | 0   | 1   | 2   | 3   | 4   | 5   |
| ----- | --- | --- | --- | --- | --- | --- |
| v     | 0   | 1   | 2   | 3   | 4   | 5   |
| w     | 0   | 1   | 2   | 3   | 4   | 5   |

| масив | 0   | 1   | 2   | 3   | 4   | 5   |
| ----- | --- | --- | --- | --- | --- | --- |
| v     | 1   | 2   | 3   | 4   | 5   | 0   |
| w     | 5   | 0   | 1   | 2   | 3   | 4   |

| масив | 0   | 1   | 2   | 3   | 4   | 5   |
| ----- | --- | --- | --- | --- | --- | --- |
| v     | 1   | 0   | 3   | 5   | 2   | 4   |
| w     | 1   | 0   | 4   | 2   | 5   | 3   |

| ![Example Matching](https://raw.githubusercontent.com/d-krupke/cpsat-primer/main/images/inverse.png) |
| :--------------------------------------------------------------------------------------------------: |
|               Візуалізація стабільного зіставлення, яке задає обмеження `add_inverse`.               |

> [!WARNING]
>
> Зазвичай я не рекомендую використовувати `add_element` і `add_inverse`
> обмеження. Хоча CP-SAT може мати ефективні техніки пропагації для них, ці
> обмеження можуть виглядати неприродними й складними. Часто простіше
> змоделювати стабільне зіставлення через бінарні змінні $x_{ij}$, які
> позначають, чи зіставлено $v_i$ з $w_j$, і застосувати `add_exactly_one` для
> кожної вершини, щоб забезпечити унікальні відповідності. Якщо ваша модель має
> враховувати певні атрибути або витрати, пов’язані зі з’єднаннями, бінарні
> змінні необхідні. Покладатися лише на індекси означає додаткову логіку для
> коректного представлення. Крім того, використовуйте небінарні змінні лише
> тоді, коли числове значення справді має семантичний зміст, який не можна
> просто переіндексувати.
