<!-- EDIT THIS PART VIA 07_under_the_hood.md -->

<a name="07-under-the-hood"></a>

## Як це працює?

<!-- START_SKIP_FOR_README -->

![Обкладинка «Як»](https://raw.githubusercontent.com/d-krupke/cpsat-primer/main/images/logo_7.webp)

<!-- STOP_SKIP_FOR_README -->

CP-SAT — це універсальний _портфельний_ розв’язувач, у центрі якого —
Constraint Programming Solver на базі _Lazy Clause Generation (LCG)_, хоча він
включає значно ширший набір технологій.

Як портфельний розв’язувач, CP-SAT одночасно запускає багато різних алгоритмів і
стратегій, кожна зі своїми сильними й слабкими сторонами. Ці компоненти працюють
здебільшого незалежно, але обмінюються інформацією, коли з’являються кращі
розв’язки або більш тісні межі.

На перший погляд це може здатися неефективним через дублювання, але на практиці
підхід дуже ефективний. Причина — складність передбачення, який алгоритм найкраще
підійде для конкретної задачі (теорема «No Free Lunch»). Тому практична стратегія
— запускати різні підходи паралельно, сподіваючись, що один із них спрацює. Ви
також можете вказати, які алгоритми використовувати, якщо вже знаєте, які
перспективні або марні.

На відміну від цього, MIP-розв’язувачі на базі Branch and Cut, як-от Gurobi,
ефективніше ділять простір пошуку, зменшуючи дублювання. Але вони спеціалізуються
на конкретній стратегії, яка не завжди найкраща, хоча часто і є такою.

CP-SAT використовує Branch and Cut техніки, включно з лінійними релаксаціями та
площинами відсікання, як частину свого арсеналу. Моделі, які добре розв’язуються
MIP-розв’язувачами, зазвичай добре підходять і для CP-SAT. Проте основний фокус
CP-SAT — Lazy Clause Generation, яка спирається на SAT-розв’язувачі, а не на
лінійні релаксації. Через це CP-SAT може бути дещо повільнішим на класичних MIP
задачах, ніж спеціалізовані MIP-розв’язувачі. Зате він має суттєву перевагу в
задачах із великою кількістю складних логічних обмежень.

Ідея Lazy Clause Generation — (інкрементально) перетворювати задачу у SAT-формулу
і використовувати SAT-розв’язувач для пошуку розв’язку (або доведення меж через
недопустимість). Щоб уникнути непродуктивної «прямої» конверсії, LCG
використовує багато лінивих змінних і клауз.

Зокрема, теорема
[Cook-Levin](https://en.wikipedia.org/wiki/Cook%E2%80%93Levin_theorem)
показує, що будь-яку NP-задачу можна звести до SAT. Теоретично оптимізацію можна
реалізувати через двійковий пошук. Але цей підхід хоч і коректний, та
неефективний. CP-SAT використовує більш витончене кодування для оптимізації.

Якщо хочете зрозуміти внутрішню кухню CP-SAT, можна пройти такий шлях навчання:

1. Навчитися знаходити допустимий розв’язок на базі булевої логіки з
   SAT-розв’язувачами: Backtracking, DPLL, CDCL, VSIDS, ...
   - [Історичний огляд від Armin Biere](https://youtu.be/DU44Y9Pt504) (відео)
   - [Donald Knuth - The Art of Computer Programming, Volume 4, Fascicle 6: Satisfiability](https://www-cs-faculty.stanford.edu/~knuth/taocp.html)
     (книга)
   - [Carsten Sinz and Tomas Baylo - Practical SAT Solving](https://baldur.iti.kit.edu/sat/#about)
     (слайди)
2. Навчитися знаходити доведено оптимальні розв’язки через класичне
   змішане цілочисельне програмування:
   - Лінійне програмування: Simplex, Duality, Dual Simplex, ...
     - [Understanding and Using Linear Programming](https://link.springer.com/book/10.1007/978-3-540-30717-4)
       (книга)
     - [Optimization in Operations Research by Ronald Rardin](https://www.pearson.com/en-us/subject-catalog/p/optimization-in-operations-research/P200000003508/9780137982066)
       (дуже велика книга, також про MIP, евристики й просунуті теми)
     - [Відеосерія від Gurobi](https://www.youtube.com/playlist?list=PLHiHZENG6W8BeAfJfZ3myo5dsSQjEV5pJ)
   - Змішане цілочисельне програмування: Branch and Bound, Cutting Planes,
     Branch and Cut, ...
     - [Discrete Optimization на Coursera з Pascal Van Hentenryck і Carleton Coffrin](https://www.coursera.org/learn/discrete-optimization)
       (відеокурс, також про CP і евристики)
     - [Ресурси Gurobi](https://www.gurobi.com/resource/mip-basics/) (сайт)
3. Вивчити додаткові концепції LCG Constraint Programming: propagation,
   Lazy Clause Generation, ...
   - [Combinatorial Optimisation and Constraint Programming від Prof. Pierre Flener (Uppsala University)](https://user.it.uu.se/~pierref/courses/COCP/slides/)
     (слайди)
   - [Доповідь Peter Stuckey](https://www.youtube.com/watch?v=lxiCHRFNgno)
     (відео)
   - [Стаття про Lazy Clause Generation](https://people.eng.unimelb.edu.au/pstuckey/papers/cp09-lc.pdf)
     (paper)
4. Вивчити деталі CP-SAT:
   - [Proto-файл параметрів](https://github.com/google/or-tools/blob/stable/ortools/sat/sat_parameters.proto)
     (source)
   - [Повний вихідний код](https://github.com/google/or-tools/tree/stable/ortools/sat)
     (source)
   - [Свіжа доповідь розробників CP-SAT](https://www.youtube.com/live/vvUxusrUcpU?si=qVsXMq0xSOsfghTM)
     (відео)
   - [Інша доповідь розробників CP-SAT](http://egon.cheme.cmu.edu/ewo/video/CP_SAT_LP_google.mp4)
     (відео)
   - [Доповідь розробників CP-SAT](https://youtu.be/lmy1ddn4cyw) (відео)

Якщо у вас вже є досвід MIP, можна відразу перейти до слайдів
[Combinatorial Optimisation and Constraint Programming](https://user.it.uu.se/~pierref/courses/COCP/slides/).
Це повний і детальний курс з constraint programming, і на його проходження
потрібен час. Але він дає знання, необхідні для розуміння CP-SAT.

> Спочатку я написав короткі вступи до кожної теми, але прибрав їх, бо
> матеріали за посиланнями значно кращі. Стару версію можна знайти
> [тут](https://github.com/d-krupke/cpsat-primer/blob/main/old_how_does_it_work.md).

### Що відбувається в CP-SAT під час solve?

Що саме відбувається при `solver.solve(model)`?

1. **Завантаження і перевірка моделі:**

   - Модель читається з protobuf-представлення.
   - Модель перевіряється на коректність.

2. **Попередня обробка (кілька ітерацій, контролюється
   `max_presolve_iterations`):**

   1. **Presolve (зменшення доменів):**
      - Це зменшує розмір задачі, спрощуючи домени змінних. Див.:
        - [Відео про SAT preprocessing](https://www.youtube.com/watch?v=ez9ArInp8w4)
        - [Відео про MaxSAT preprocessing](https://www.youtube.com/watch?v=xLg4hbM8ooM)
        - [Стаття про MIP presolving](https://opus4.kobv.de/opus4-zib/frontdoor/index/index/docId/6037)
   2. **Розгортання високорівневих обмежень:**
      - Високорівневі обмеження перетворюються на нижчорівневі, які CP-SAT може
        ефективно пропагувати, але які менш зручні для запису. Аналогічний
        процес — [FlatZinc і Flattening](https://www.minizinc.org/doc-2.5.5/en/flattening.html).
   3. **Виявлення еквівалентних змінних і афінних зв’язків:**
      - Ідентифікуються афінні зв’язки на кшталт `a * x + b = y`. Детальніше:
        [affine relations](https://personal.math.ubc.ca/~cass/courses/m309-03a/a1/olafson/affine_fuctions.htm).
   4. **Заміна на канонічні представлення:**
      - Виявлені афінні зв’язки замінюються канонічними представленнями.
   5. **Пробінг змінних:**
      - Деякі змінні тестуються, щоб визначити, чи можна їх зафіксувати або
        виявити інші еквівалентності.

3. **Завантаження і релаксація:**

   - Попередньо оброблена модель завантажується у внутрішній solver, і
     створюються лінійні релаксації.

4. **Пошук розв’язку:**

   - Solver шукає розв’язки і межі, доки нижня і верхня межі не збіглися або
     не спрацював інший критерій зупинки (наприклад, ліміт часу).
   - Запускаються кілька повних сабсолверів у різних потоках з різними
     стратегіями:
     - більш лінеаризовані моделі
     - агресивні рестарти
     - фокус на нижній або верхній межі
   - Теоретично кожен сабсолвер може знайти оптимум, але деякі швидші.

5. **Пошук першого розв’язку і локальний пошук:**

   - Додаткові «first solution searchers» запускаються на вільних потоках.
     Вони зупиняються після знаходження допустимого розв’язку.
   - Після цього активуються неповні сабсолвери, що застосовують локальний
     пошук, наприклад Large Neighborhood Search (LNS).
   - Під час кожної ітерації LNS:
     1. Робиться копія моделі, і обирається розв’язок з пулу.
     2. Частина змінних «виймається» (спосіб вибору відрізняється за
        стратегіями). Для цих змінних досліджується околиця.
     3. Решта змінних фіксується у копії моделі.
     4. Спрощена модель проходить presolve, що робить її легшою.
     5. Спрощена модель розв’язується повною стратегією з коротким лімітом
        часу і одним потоком.
     6. Якщо знайдено новий розв’язок, він додається у пул.

6. **Трансформація розв’язку:**
   - Фінальний розв’язок трансформується назад у формат початкової моделі,
     щоб ви могли читати значення змінних у вихідному вигляді.

Це взято з [цієї доповіді](https://youtu.be/lmy1ddn4cyw?t=434) і трохи розширено.

### Використання лінійного програмування

Як уже згадувалося, CP-SAT також використовує (dual) simplex і лінійні
релаксації. Лінійна релаксація реалізована як пропагатор і може виконуватися
на кожному вузлі дерева пошуку, але з найнижчим пріоритетом. Важлива різниця
порівняно з Branch and Bound: виконується лише частина pivot-ітерацій (для
швидкості). Оскільки дерева пошуку можуть бути глибшими і використовується
warm-start, оптимальна лінійна релаксація все одно може бути обчислена, але
глибше у дереві (у SAT-розв’язуванні дерево часто обходиться DFS). На корені
використовуються навіть відсікання на кшталт Gomory-cuts, щоб покращити
лінійну релаксацію.

Лінійна релаксація використовується для виявлення недопустимості (IP можуть
бути потужніші за SAT, принаймні теоретично), для покращення меж цілі і змінних,
а також для прийняття рішень щодо розгалуження (на основі цілі релаксації та
reduced costs).

Використаний Relaxation Induced Neighborhood Search RINS (LNS worker), дуже
успішна евристика, теж використовує лінійне програмування.

### Обмеження CP-SAT

Хоч CP-SAT є дуже потужним solver-ом, він має певні обмеження у порівнянні з
альтернативами:

1. Хоч він ефективний, він може бути повільнішим за спеціалізований SAT-solver
   при розв’язанні SAT-формул, хоча якість все одно дуже висока.
2. Для класичних MIP-задач CP-SAT може не перевершити спеціалізовані
   MIP-розв’язувачі, хоча результати часто все одно хороші.
3. На відміну від MIP/LP-розв’язувачів, CP-SAT не має неперервних змінних, а
   обхідні шляхи не завжди ефективні. Якщо задача здебільшого має неперервні
   змінні та лінійні обмеження, LP-розв’язувач, швидше за все, буде значно
   швидшим.
4. CP-SAT не підтримує lazy constraints або інкрементальне побудування моделі,
   що доступно в MIP/LP-розв’язувачах і деяких SAT-розв’язувачах. Тому
   застосування моделей експоненційного розміру (типових у MIP) може бути
   обмеженим.
5. CP-SAT обмежується Simplex і не має interior point методів. Це означає, що
   він не може використовувати поліноміальні алгоритми для певних класів
   квадратичних обмежень, як-от Second Order Cone. На відміну від нього,
   Gurobi застосовує Barrier алгоритм і розв’язує такі обмеження поліноміально.

CP-SAT також може бути неефективним для деяких обмежень, наприклад modulo.
Втім, мені не відомо жодного альтернативного solver-а, який ефективно працює
з такими обмеженнями. Іноді NP-складні задачі об’єктивно дуже складні, і
доводиться шукати більш зручні моделювальні підходи, а не кращі solver-и.
