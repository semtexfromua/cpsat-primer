<!-- EDIT THIS PART VIA 03_big_picture.md -->

<a name="section-alternatives"></a> <a name="03-big-picture"></a>

## Альтернативи: місце CP-SAT у світі оптимізації

<!-- START_SKIP_FOR_README -->

![Обкладинка «Світ оптимізації»](https://raw.githubusercontent.com/d-krupke/cpsat-primer/main/images/logo_8.webp)

<!-- STOP_SKIP_FOR_README -->

Коли ви починаєте досліджувати оптимізацію, то зустрінете безліч інструментів,
технік і спільнот. Це може збивати з пантелику, адже ці групи, маючи багато
спільного, водночас суттєво відрізняються. Вони можуть використовувати ту саму
термінологію для різних понять або різні терміни для однакових понять, що ще
більше плутає. Небагато експертів уміють ефективно орієнтуватися в цих різних
спільнотах і техніках. Часто навіть вузькі спеціалісти, включно з професорами,
зосереджуються на одній техніці чи спільноті й не знають про потенційно
ефективніші методи, розроблені в інших колах.

Якщо вам цікаві зв’язки між різними концепціями оптимізації, перегляньте
доповідь
[Logic, Optimization, and Constraint Programming: A Fruitful Collaboration](https://simons.berkeley.edu/talks/john-hooker-carnegie-mellon-university-2023-04-19)
від John Hooker. Зауважте, що це академічна презентація і вона передбачає певну
обізнаність із теоретичною інформатикою.

Тепер розгляньмо доступні інструменти й техніки та порівняймо їх із CP-SAT.
Будь ласка, пам’ятайте, що це огляд високого рівня і він не є вичерпним. Якщо у
вас є суттєві доповнення — відкрийте issue, і я розгляну можливість їхнього
включення.

- **Змішане цілочисельне (лінійне) програмування (MIP):** MIP — надзвичайно
  ефективний метод для розв’язання різноманітних оптимізаційних задач,
  особливо тих, що стосуються мереж, наприклад задач потоків чи турів. Хоча
  MIP підтримує лише лінійні обмеження, що робить його менш виразним, ніж CP-SAT,
  він часто є найкращим вибором, якщо ваша модель сумісна з такими обмеженнями.
  CP-SAT включає техніки з MIP, але з обмеженнями, зокрема відсутністю
  неперервних змінних і інкрементального моделювання. Тому «чисті» MIP-розв’язувачі,
  як більш спеціалізовані, зазвичай ефективніші для певних застосувань.
  Помітні MIP-розв’язувачі:
  - [Gurobi](https://www.gurobi.com/): комерційний розв’язувач, відомий своїми
    передовими можливостями в MIP. Пропонує безкоштовні академічні ліцензії,
    відмінну продуктивність, зручність використання та сильну підтримку через
    документацію й вебінари з експертами. Особливо вражає здатністю працювати зі
    складними великомасштабними задачами.
  - [SCIP](https://www.scipopt.org/): розв’язувач з відкритим кодом із Python-інтерфейсом.
    Хоча він не такий ефективний і дружній, як Gurobi, SCIP дозволяє глибоку
    кастомізацію і є ідеальним для досліджень та розробки, особливо для експертів,
    яким потрібно реалізовувати складні техніки декомпозиції. Якщо ви вмієте ним
    користуватися, для деяких задач (особливо з Branch and Price) можна досягти
    кращої продуктивності, ніж будь-яким іншим розв’язувачем.
  - [FICO Xpress Optimization](https://www.fico.com/en/products/fico-xpress-optimization):
    ще один популярний комерційний розв’язувач. Багато розробників SCIP зрештою
    переходять працювати або в Gurobi, або в Xpress.
  - [COPT Cardinal Solver](https://www.copt.de/): відносно новий комерційний
    розв’язувач, який, здається, дуже сильний для деяких класів задач.
  - [HiGHS](https://highs.dev/): новіший розв’язувач під ліцензією MIT, що є
    цікавою альтернативою SCIP. Він, імовірно, швидший і має більш дружній
    інтерфейс, але менш універсальний. Для бенчмарків продуктивності див.
    [тут](https://plato.asu.edu/ftp/milp.html).
- **Програмування з обмеженнями (CP):** CP — більш загальний підхід до задач
  оптимізації, ніж MIP. Як випливає з назви, він зосереджується на обмеженнях,
  і розв’язувачі зазвичай мають багато просунутих обмежень, які дозволяють
  природніше описувати задачу. Класичний приклад — обмеження `AllDifferent`,
  яке дуже складно змоделювати в MIP, але воно дозволяє, наприклад, тривіально
  змоделювати судоку. CP був дуже успішним, наприклад, у розв’язанні задач
  планування, де є багато обмежень, які складно описати лінійно. Внутрішні
  техніки CP-розв’язувачів часто більше опираються на логіку й менше — на
  лінійну алгебру, порівняно з MIP-розв’язувачами. Популярні CP-розв’язувачі:
  - [CP-SAT від OR-Tools](https://github.com/google/or-tools/): розглядається в
    цьому праймері; CP-SAT поєднує різні оптимізаційні техніки, зокрема з MIP,
    але його ключова техніка — Lazy Clause Generation. Цей підхід переводить
    задачі у (Max-)SAT формули для розв’язання.
  - [Choco](https://choco-solver.org/): традиційний CP-розв’язувач, написаний на
    Java і ліцензований за BSD 4-Clause. Хоча він може поступатися CP-SAT у
    ефективності чи сучасності, Choco пропонує значну гнучкість, зокрема можливість
    інтегрувати власні пропагатори.
- **SAT-розв’язувачі:** якщо ваша задача полягає лише в пошуку допустимого
  розв’язку для булевих змінних, варто подумати про SAT-розв’язувач. Вони
  напрочуд ефективні й часто здатні працювати з задачами з мільйонами змінних.
  Якщо підійти креативно, можна виконувати й деякі оптимізаційні задачі за
  допомогою SAT-розв’язувачів, як це робить CP-SAT. Більшість SAT-розв’язувачів
  підтримують інкрементальне моделювання, а деякі — обмеження кардинальності.
  Однак це досить низькорівневі інструменти, і CP-SAT може досягати подібної
  продуктивності для багатьох задач. Популярна бібліотека SAT-розв’язувачів:
  - [PySAT](https://pysathq.github.io/): Python-бібліотека під ліцензією MIT,
    що надає зручний інтерфейс до багатьох SAT-розв’язувачів. Її легко
    використовувати, і вона дозволяє перемикатися між розв’язувачами без змін
    коду. Гарний вибір для експериментів із SAT-розв’язувачами.
  - Щороку з’являється багато нових розв’язувачів, і чимало з них мають відкритий
    код. Перегляньте [SAT Competition](http://www.satcompetition.org/), щоб
    побачити актуальний стан мистецтва. Більшість розв’язувачів написані на C
    або C++ і мають небагато документації. Проте, оскільки SAT-формули дуже
    прості, а розв’язувачі зазвичай не мають складних залежностей, ними все ще
    можна користуватися доволі легко.
- **Задовільність з урахуванням теорій (SMT):** SMT-розв’язувачі — це наступний
  щабель після традиційних SAT-розв’язувачів. Вони перевіряють
  задовільність математичних формул, розширюючи пропозиційну логіку додатковими
  теоріями, як-от лінійна арифметика, бітові вектори, масиви й квантори.
  Наприклад, SMT-розв’язувач може визначити, чи є формула задовільною за умов,
  що всі змінні — цілі числа з певними лінійними обмеженнями. Подібно до Lazy
  Clause Generation у CP-SAT, SMT-розв’язувачі зазвичай використовують SAT
  у бекенді, доповнений складними кодуваннями й додатковими пропагаторами для
  підтримки великого набору виразів. Ці розв’язувачі широко застосовують у
  автоматизованому доведенні теорем і верифікації систем. Популярний SMT-розв’язувач:
  - [Z3](https://github.com/z3prover/z3): розроблений Microsoft і доступний за
    ліцензією MIT. Z3 має надійний Python-інтерфейс і ґрунтовну документацію,
    що робить його доступним для широкого спектра застосувань.
- **Нелінійне програмування (NLP):** багато MIP-розв’язувачів насправді можуть
  обробляти деякі нелінійні обмеження, адже з часом з’ясувалося, що певні
  техніки є більш загальними, ніж просто лінійні обмеження; наприклад, методи
  внутрішніх точок можуть також розв’язувати задачі з конічними обмеженнями
  другого порядку. Проте ви помітите значне падіння продуктивності, оскільки
  нелінійність набагато складніше обробляти. Якщо ваші обмеження та цілі стають
  надто складними, такі розв’язувачі можуть перестати бути життєздатним
  варіантом. На щастя, у цій області зараз багато руху, і можна очікувати, що
  великі розв’язувачі (Gurobi, COPT, Xpress тощо) ставатимуть дедалі кращими в
  роботі з такими задачами. Якщо у вас невеликі оптимізаційні задачі майже будь-якого
  типу, варто розглянути:
  - [SciPy](https://docs.scipy.org/doc/scipy/reference/optimize.html): Python-бібліотека,
    що пропонує широкий набір алгоритмів оптимізації. Не очікуйте, що вона
    наблизиться до продуктивності спеціалізованих розв’язувачів, але вона дає
    багато різних опцій для розв’язання широкого спектра задач.
- **Мови моделювання:** мови моделювання надають високорівневий, зручний інтерфейс
  для формулювання оптимізаційних задач, зосереджуючись на труднощах розробки й
  підтримки моделей, що точно відображають реальні сценарії. Ці мови є
  незалежними від конкретних розв’язувачів, дозволяючи легко перемикатися між
  різними розв’язувачами — наприклад, від безкоштовного SCIP до комерційного
  Gurobi — без зміни самої моделі. Вони також полегшують використання різних
  технік, як-от перехід між програмуванням з обмеженнями і змішаним цілочисельним
  програмуванням. Однак компроміс — потенційна втрата контролю й продуктивності
  заради універсальності та простоти. Найпопулярніші мови моделювання:
  - [MiniZinc](https://www.minizinc.org/): дуже добре задокументована і безкоштовна
    мова моделювання, що має високу репутацію в академічній спільноті. Вона
    використовується, зокрема, у
    [чудовому курсі з програмування з обмеженнями від Pierre Flener](https://user.it.uu.se/~pierref/courses/COCP/slides/).
    Підтримує багато бекендів, а також є
    [MiniZinc Challenges](https://www.minizinc.org/challenge/), де CP-SAT здобув
    чимало медалей.
  - [AMPL](https://ampl.com/): можливо, найпопулярніша мова моделювання. Має як
    безкоштовні, так і комерційні розв’язувачі. Є не лише ґрунтовна документація,
    а й навіть книга про те, як нею користуватися.
  - [GAMS](https://www.gams.com/): комерційна система, що підтримує багато
    розв’язувачів і отримала Python-інтерфейс. Я особисто знаю людей із GAMS,
    бо у них є офіс у Брауншвейгу. Вони мають великий досвід в оптимізації, але
    сам я їхнє ПЗ не використовував.
  - [pyomo](http://www.pyomo.org/): Python-бібліотека, що дозволяє моделювати
    оптимізаційну задачу в Python, а потім розв’язувати її різними розв’язувачами.
    Вона не така високорівнева, як AMPL чи GAMS, але є безкоштовною та з
    відкритим кодом. Дуже гнучка і дозволяє моделювати в Python, що є великою
    перевагою, якщо ви вже знайомі з Python. Вона має підтримку CP-SAT і може
    бути варіантом, якщо вам потрібне швидке рішення.
  - [MathOpt від OR-Tools](https://developers.google.com/optimization/math_opt):
    дуже новий конкурент і «родич» CP-SAT. Підтримує лише кілька розв’язувачів,
    але все одно може бути цікавим.
- **Спеціалізовані алгоритми:** для багатьох оптимізаційних задач існують
  спеціалізовані алгоритми, які можуть бути значно ефективнішими за
  універсальні розв’язувачі. Приклади:
  - [Concorde](http://www.math.uwaterloo.ca/tsp/concorde.html): розв’язувач для
    задачі комівояжера, який, попри свій вік, все ще дуже швидкий для багатьох
    екземплярів.
  - [Routing Solver від OR-Tools](https://developers.google.com/optimization/routing):
    OR-Tools також має окремий розв’язувач для маршрутних задач.
  - [Network Flows від OR-Tools](https://developers.google.com/optimization/flow):
    OR-Tools також має окремий розв’язувач для задач мережевих потоків.
  - ...
- **Алгоритми наближення:** для багатьох складних оптимізаційних задач можна
  знайти наукові статті, що описують алгоритми наближення. Ці алгоритми мають
  певні гарантії того, що результат не буде надто далеким від оптимального
  розв’язку. Деякі навіть доведено досягають найкращих можливих гарантій. Однак
  не варто намагатися безпосередньо реалізувати таку статтю, навіть якщо вона
  ідеально підходить до вашої задачі. Деякі алгоритми наближення справді
  практичні, але багато — ні. Гарантії зазвичай зосереджені на штучних
  найгірших сценаріях, і навіть якщо алгоритм можна реалізувати, його часто
  легко перевершують прості евристики. Алгоритми наближення і їхній аналіз
  можуть бути корисними для розуміння структури задачі, але пряме практичне
  використання обмежене.
- **Мета-евристики:** замість використання універсального розв’язувача, як CP-SAT,
  ви можете спробувати створити власний алгоритм для задачі на основі певного
  шаблону мета-евристики, наприклад імітації відпалу, генетичних алгоритмів
  чи табу-пошуку. Мета-евристики потребують певного програмування, але щойно
  ви зрозумієте шаблон, їх досить просто реалізувати. Хоча існують бібліотеки,
  що узагальнюють частини цих алгоритмів, ви також можете написати весь алгоритм
  самостійно. Це дає перевагу справді розуміти, що відбувається в алгоритмі,
  але ви втрачаєте багато просунутих технік, наявних у розв’язувачах на кшталт
  CP-SAT. Для багатьох оптимізаційних задач вам буде складно конкурувати з
  рішеннями, що використовують сучасні розв’язувачі, з погляду якості розв’язку.
  Якщо вам потрібне швидке рішення, мета-евристики можуть бути хорошим стартом.

Як видно, існує різноманітний набір інструментів і технік для розв’язання
оптимізаційних задач. CP-SAT вирізняється як універсальний підхід, особливо
добре пристосований до комбінаторної оптимізації. Якщо ви часто маєте справу з
такими задачами, вивчення CP-SAT дуже рекомендується. Його ефективність у
широкому спектрі сценаріїв — і особливо у багатьох з них — вражає для інструмента,
який є безкоштовним і відкритим.

---
