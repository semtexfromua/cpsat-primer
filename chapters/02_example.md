<!-- EDIT THIS PART VIA 02_example.md -->

<a name="02-example"></a>

## Простий приклад

<!-- START_SKIP_FOR_README -->

![Обкладинка прикладу](https://raw.githubusercontent.com/d-krupke/cpsat-primer/main/images/logo_example.webp)

<!-- STOP_SKIP_FOR_README -->

Перш ніж заглиблюватися у внутрішні деталі, швидко погляньмо на просте
застосування CP-SAT. Приклад настільки простий, що його можна розв’язати вручну,
але пам’ятайте, що CP-SAT (ймовірно) нормально впорається, якщо ви додасте
тисячу (а можливо й десятки чи сотні тисяч) змінних і обмежень більше. Базова
ідея використання CP-SAT, подібно до MIP, — визначити оптимізаційну задачу через
змінні, обмеження й цільову функцію, а потім дозволити розв’язувачу знайти
розв’язок. Таку формалізацію, яку відповідний розв’язувач може зрозуміти,
називають _моделлю_ задачі. Для тих, хто не знайомий із
[декларативним підходом](https://programiz.pro/resources/imperative-vs-declarative-programming/),
можна провести аналогію з SQL: ви описуєте, які дані хочете отримати, а не як
їх добути. Втім, це не суто декларативний підхід, адже те, _як_ ви моделюєте
задачу, може мати величезне (!) значення, і правильне моделювання потребує
досвіду та розуміння внутрішньої роботи. Для невеликих задач (скажімо, кілька
сотень або тисяч змінних) ви можете просто «пощастити» й отримати оптимальні
розв’язки, не маючи чіткого уявлення про те, що відбувається. Розв’язувачі
щороку все краще справляються з «поганими» моделями.

> [!NOTE]
>
> **Модель** у математичному програмуванні означає математичний опис задачі, що
> складається зі змінних, обмежень і, за потреби, цільової функції, яку може
> розуміти відповідний клас розв’язувачів. _Моделювання_ — це перетворення
> задачі (екземпляра) у відповідну форму, наприклад перетворення всіх обмежень
> у лінійні, як цього вимагає змішане цілочисельне лінійне програмування. Зауважте,
> що спільнота [SAT](https://en.wikipedia.org/wiki/SAT_solver) використовує
> термін _model_ для позначення (допустимого) присвоєння змінних, тобто розв’язку
> SAT-формули. Якщо ви плутаєтеся в термінах, можливо, варто прочитати короткий
> гайд
> [Math Programming Modelling Basics](https://www.gurobi.com/resources/math-programming-modeling-basics/).

Наша перша задача не має глибшого сенсу, окрім демонстрації базового робочого
процесу: створення змінних (x і y), додавання обмеження $x+y<=30$, задання цілі
(максимізувати $30x + 50y$) і отримання розв’язку:

```python
from ortools.sat.python import cp_model

model = cp_model.CpModel()

# Змінні
x = model.new_int_var(0, 100, "x")
y = model.new_int_var(0, 100, "y")

# Обмеження
model.add(x + y <= 30)

# Ціль
model.maximize(30 * x + 50 * y)

# Розв’язання
solver = cp_model.CpSolver()
status_code = solver.solve(model)
status_name = solver.status_name()

# Виводимо статус розв’язувача та оптимальний розв’язок.
print(f"{status_name} ({status_code})")
print(f"x={solver.value(x)},  y={solver.value(y)}")
```

    OPTIMAL (4)
    x=0,  y=30

Дуже просто, так? Для розв’язання загальної задачі, а не одного конкретного
екземпляра, ви, звісно, створите словник або список змінних і використаєте
щось на кшталт `model.add(sum(vars)<=n)`, адже ви не хочете вручну створювати
модель для великих екземплярів.

Розв’язувач може повертати п’ять різних статусів:

| Статус          | Код | Опис                                                                                                                                                                                         |
| --------------- | ---- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `UNKNOWN`       | 0    | Розв’язувач працював недостатньо довго.                                                                                                                                                       |
| `MODEL_INVALID` | 1    | Модель некоректна. Такий статус трапляється рідко.                                                                                                                                            |
| `FEASIBLE`      | 2    | Модель має допустимий, але не обов’язково оптимальний, розв’язок. Якщо цільова функція відсутня, кожна допустима модель повертає `OPTIMAL`, що може бути неочевидно.                        |
| `INFEASIBLE`    | 3    | Модель не має допустимого розв’язку. Це означає, що обмеження надто жорсткі.                                                                                                                   |
| `OPTIMAL`       | 4    | Модель має оптимальний розв’язок. Якщо цільова функція відсутня, повертається `OPTIMAL` замість `FEASIBLE`.                                                                                   |

> [!TIP]
>
> Статусу `UNBOUNDED` _немає_, оскільки в CP-SAT немає необмежених змінних.
> Класичні MIP-розв’язувачі дозволяють необмежені змінні, що може призводити до
> необмежених розв’язків, тобто цільова функція може необмежено зростати або
> спадати без досягнення максимуму чи мінімуму. У програмуванні з обмеженнями
> необмежені домени зазвичай не допускаються і не є корисними. Натомість у
> лінійному програмуванні вони важливі, наприклад при використанні двоїстості.

Для великих моделей CP-SAT, на жаль, не завжди зможе знайти оптимальний
розв’язок. Але гарна новина в тому, що розв’язувач, ймовірно, все одно знайде
задовільний розв’язок і надасть межу для оптимального значення. На цьому етапі
вміння інтерпретувати лог розв’язувача стає критично важливим для аналізу його
продуктивності. Про це ми поговоримо пізніше.

### Математична модель

Математична модель наведеного вище коду зазвичай записується експертами так:

```math
\max 30x + 50y
```

```math
\text{s.t. } x+y \leq 30
```

```math
\quad 0\leq x \leq 100
```

```math
\quad 0\leq y \leq 100
```

```math
x,y \in \mathbb{Z}
```

` s.t.` означає `subject to`, інколи також читають як `such that`.

### Перевантаження операторів

Один із аспектів використання CP-SAT, що часто викликає труднощі у новачків, —
це розуміння перевантаження операторів у Python і відмінностей між двома типами
змінних. У цьому контексті `x` і `y` — це математичні змінні. Тобто це
заглушки, яким конкретні значення будуть присвоєні лише під час розв’язання.
Щоб проілюструвати це точніше, розгляньмо приклад у Python-оболонці:

```pycon
>>> model = cp_model.CpModel()
>>> x = model.new_int_var(0, 100, "x")
>>> x
x(0..100)
>>> type(x)
<class 'ortools.sat.python.cp_model.IntVar'>
>>> x + 1
sum(x(0..100), 1)
>>> x + 1 <= 1
<ortools.sat.python.cp_model.BoundedLinearExpression object at 0x7d8d5a765df0>
```

У цьому прикладі `x` — не звичайне число, а заглушка, що потенційно може
приймати будь-яке значення між 0 і 100. Коли до `x` додаємо 1, результатом
стає нова заглушка, що представляє суму `x` і 1. Аналогічно, порівняння цієї
суми з 1 породжує ще одну заглушку, яка інкапсулює сам факт порівняння. На цьому
етапі ці заглушки не мають конкретних значень, але вони потрібні для опису
обмежень моделі. Спроба виконати операцію на кшталт `if x + 1 <= 1: print("True")`
викличе `NotImplementedError`, адже умова `x+1<=1` не може бути безпосередньо
оцінена.

Хоча такий спосіб опису моделей може спочатку здаватися дивним, він дозволяє
наблизитися до математичної нотації, що, у свою чергу, полегшує виявлення та
виправлення помилок у моделі.

### Більше прикладів

Якщо вам замало,
[ця папка містить багато Jupyter Notebook-прикладів від розробників](https://github.com/google/or-tools/tree/stable/examples/notebook/sat).
Наприклад:

- [multiple_knapsack_sat.ipynb](https://github.com/google/or-tools/blob/stable/examples/notebook/sat/multiple_knapsack_sat.ipynb)
  показує, як розв’язати задачу про кілька рюкзаків.
- [nurses_sat.ipynb](https://github.com/google/or-tools/blob/stable/examples/notebook/sat/nurses_sat.ipynb)
  показує, як складати графік змін медсестер.
- [bin_packing_sat.ipynb](https://github.com/google/or-tools/blob/stable/examples/notebook/sat/bin_packing_sat.ipynb)
  показує, як розв’язати задачу пакування в контейнери (bin packing).
- ... (якщо ви знаєте ще гарні приклади, які варто згадати тут — дайте знати!)

Крім того, є великий і дружній до початківців приклад розкладу працівників
[тут](https://pganalyze.com/blog/a-practical-introduction-to-constraint-programming-using-cp-sat).

Тепер, коли ви побачили мінімальну модель, давайте розглянемо різні варіанти
моделювання задач. Хоча досвідчений оптимізатор може впоратися з більшістю задач,
використовуючи лише щойно описані елементи, чітке формулювання ваших намірів
може допомогти CP-SAT ефективніше оптимізувати задачу.

> :video:
>
> Оптимізаційні задачі всюди в реальному світі. Якщо вам потрібен швидкий
> огляд практичних застосувань, відео
> [Optimization 360 (Optimization Everywhere)](https://www.youtube.com/watch?v=bWbCjedszc0&list=PLHiHZENG6W8B7f6OEiDg5Gj0Jz35iZ17Z&index=3)
> з тренінгу Gurobi Opti 202 показує різноманітні домени, де
> оптимізація відіграє ключову роль.
>
> Ось підсумкова таблиця прикладів задач з відео:
>
> | **Задача / Домен**                      | **Оптимізаційний виклик**                                                                                                            |
> | --------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
> | Переробка молока та молочної продукції  | Змішати сире молоко з різним вмістом жиру/білка, щоб отримати стабільні кінцеві продукти (молоко, масло, сир).                       |
> | Робота енергомережі                     | Планувати та диспетчеризувати генерацію електроенергії на кількох горизонтах часу, підтримуючи стабільність мережі та регуляторні вимоги. |
> | Формування кормів для тварин            | Обирати суміші інгредієнтів, що мінімізують вартість, дотримуючись харчових обмежень і лімітів доступності.                         |
> | Ланцюг постачання авто та запаси        | Визначати, які моделі та конфігурації авто тримати в дилерів, балансуючи попит, кастомізацію та витрати на запаси.                  |
> | Екологічна відповідність (Toyota)       | Розподіляти виробництво авто між ринками, щоб дотриматися норм викидів і паливної ефективності з мінімальною вартістю.              |
> | Логістика деталей і попереднє секвенсування (Audi) | Упорядковувати тисячі деталей авто в обмежених зонах і доставляти їх на конвеєр у правильному порядку.                      |
> | Перерозподіл шкільних округів           | Призначати учнів до шкіл з урахуванням місткості, відстані, цілісності спільноти та справедливості.                                |
> | Поповнення готівки в банкоматах          | Планувати доставки готівки до банкоматів, мінімізуючи простоювання капіталу та транспортні витрати, запобігаючи дефіциту.           |
> | Планування змін персоналу               | Призначати працівників на зміни, дотримуючись справедливості, лімітів навантаження, правових вимог і потреб організації.           |
> | Лісове господарство та стале вирубування | Планувати рубки та висадку протягом десятиліть, максимізуючи довгостроковий врожай і збереження вуглецю при сталому підході.        |
> | Доставка посилок (останній кілометр)    | Призначати посилки на маршрути та водіїв у великому масштабі, враховуючи географію й знайомість водія з місцевістю.                 |
> | Локації фудтраків                       | Обирати щоденні місця для автопарку фудтраків, максимізуючи очікуваний прибуток з огляду на просторовий попит.                      |
> | Спортивні розклади / розподіл команд    | Створювати збалансовані розклади матчів або чесні команди з урахуванням рівнів навичок і обмежень учасників.                       |
> | Ціноутворення супермаркетів             | Спільно встановлювати ціни на сотні взаємопов’язаних товарів, максимізуючи дохід із урахуванням ефектів заміщення.                  |
> | Платформи доставки їжі (Instacart)      | Зіставляти водіїв, клієнтів і ресторани за умов невизначеного попиту та доступності, щоб доставляти замовлення ефективно і надійно. |
