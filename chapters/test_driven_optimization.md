# Test-driven development із CP-SAT

<!-- START_SKIP_FOR_README -->

![Cover Image](https://raw.githubusercontent.com/d-krupke/cpsat-primer/main/images/crashtest_platypus.webp)

<!-- STOP_SKIP_FOR_README -->

<a name="test-driven-optimization"></a>

У цьому розділі ми покажемо, як застосувати принципи test-driven development
(TDD) до задачі складання графіків медсестер із використанням CP-SAT. Наша мета
— побудувати модульну, ретельно протестовану, розширювану й просту в супроводі
модель.

Я вважаю TDD корисним підходом для оптимізаційних задач, хоча й не дотримуюся
формального циклу TDD буквально. Раннє написання тестів допомагає уточнювати
вимоги, покращувати постановку задачі та виявляти неоднозначності у первинному
формулюванні. У багатьох реальних сценаріях постановка неповна або змінюється.
Виражаючи очікування у вигляді виконуваних тестів, ми ефективніше комунікуємо
вимоги й коригуємо їх, коли з’являються нові інсайти.

Задача формування графіка медсестер особливо добре підходить для ілюстрації
цього підходу. Вона належить до класу задач планування, де обмеження й цілі
часто змінюються у відповідь на фідбек стейкхолдерів. У таких умовах модульний
дизайн і систематичне тестування суттєво зменшують вартість адаптації й
валідації моделі при зміні вимог.

Для невеликих або чітко визначених задач може бути достатньо простої реалізації
з кількома ручними перевірками. Але зі зростанням складності та ускладненням
неформальної перевірки результатів структурований TDD-підхід стає дуже корисним.
Він дозволяє розбити задачу на менші тестовані компоненти, які можна
інкрементально реалізовувати, перевіряти та вдосконалювати.

Цей розділ не закликає до ідеальності з першої спроби. На практиці спочатку
зазвичай з’являється робочий прототип, а покращення дизайну додаються тоді, коли
це дає очевидну користь. Ключове — підтримувати баланс між швидким
прототипуванням та введенням структури і тестів на відповідному етапі
розробки.

Ми інкрементально побудуємо модель графіків медсестер на CP-SAT, керуючись
TDD-принципами. Робочий процес включає формалізацію **схем даних** для входів і
виходів, реалізацію **solver-незалежних функцій валідації**, що кодують
обмеження й цілі, а також створення **модульних компонентів** для змінних
рішення, обмежень і м’яких цілей. Наприкінці ми об’єднаємо ці модулі в
повноцінний розв’язувач і перевіримо його на тестових екземплярах. Перед цим
ми коротко розглянемо класичний підхід і те, що може піти не так зі зростанням
складності задачі.

> :warning:
>
> Цей розділ не є жорстким керівництвом, а лише одним із можливих підходів. Я не
> слідую кожному описаному тут кроку в кожному проєкті. Натомість я ділюся
> принципами, які виявилися корисними на практиці. Дослідники операцій можуть
> почерпнути ідеї зі світу інженерії ПЗ, а програмні інженери — навчитися
> застосовувати свої навички до оптимізаційних моделей. Досвідчені оптимізатори
> можуть порівняти свій підхід із представленим тут.

---

> :video:
>
> Схоже, що матеріалів про практики інженерії ПЗ саме в операційних дослідженнях
> небагато. Втім, доповідь
> [_Optimization Modeling: The Art of Not Making It an Art_](https://www.gurobi.com/events/optimization-modeling-the-art-of-not-making-it-an-art/)
> Рональда ван дер Велдена (Gurobi) є чудовим ресурсом, який частково
> перекривається з темами цього розділу. (Примітка: для доступу потрібна
> реєстрація з назвою компанії та email.)

Повний код до цього розділу можна знайти
[тут](https://github.com/d-krupke/cpsat-primer/tree/main/examples/tdd).

## Класичні кроки для «підручникових» задач

<!-- Від аудиторії до складної реальності -->

Перш ніж перейти до більш просунутого TDD-підходу, коротко згадаємо класичний
спосіб побудови оптимізаційних моделей, типовий для підручників і домашніх
завдань. Такий підхід може бути ефективним і для багатьох реальних задач, якщо
їхня складність помірна. Однак реальні задачі часто додають проблеми, яких немає
в добре структурованих академічних вправах. Із ростом складності класичний
підхід стає важким у супроводі. Тому ми розглянемо, як практики інженерії ПЗ
допомагають із цими викликами.

Розгляньмо конкретний приклад: **задачу розміщення об’єктів (FLP)**. Для
контексту подамо її так, ніби вона сформульована в домашньому завданні:

<!-- Підручникова вправа FLP -->

> Компанія з доставки планує відкрити нові склади, щоб обслуговувати клієнтів.
> Є множина $F$ потенційних локацій складів та множина $C$ клієнтів, які мають
> отримати замовлення.
>
> Відкриття складу в локації $i \in F$ має фіксовану вартість $f_i$. Доставка
> товарів зі складу $i \in F$ до клієнта $j \in C$ коштує $c_{i,j}$.
>
> Кожен клієнт $j \in C$ має обслуговуватися рівно одним складом, і склад може
> відправляти товари лише якщо він відкритий.
>
> Компанія має вирішити, які локації складів $i \in F$ відкривати, і який склад
> обслуговуватиме кожного клієнта $j \in C$, щоб загальна вартість — відкриття
> $f_i$ і доставки $c_{i,j}$ — була мінімальною.

<!-- Підхід до перетворення на математичну модель -->

Далі має сенс виділити параметри, рішення, обмеження та цілі в тексті (наприклад,
різними кольорами) і записати математичну постановку у таких кроках:

1. **Параметри:** визначити параметри задачі — вхідні дані моделі.
2. **Змінні рішення:** визначити змінні, що представляють рішення або призначення.
3. **Обмеження та цілі:** задати обмеження, яких потрібно дотриматися, і цілі
   оптимізації.

<!-- Математична модель -->

Для цієї задачі це виглядатиме так:

> **Параметри:**
>
> - $F$: множина потенційних локацій об’єктів.
> - $C$: множина клієнтів.
> - $f_i \in \mathbb{N}_0$ для $i \in F$: фіксована вартість відкриття об’єкта $i$.
> - $c_{i,j} \in \mathbb{N}_0$ для $i \in F, j \in C$: вартість обслуговування
>   клієнта $j$ з об’єкта $i$.
>
> **Змінні рішення:**
>
> - $y_i \in \mathbb{B} \ \forall i \in F$: $y_i = 1$, якщо об’єкт $i$ відкрито,
>   і 0 інакше.
> - $x_{i,j} \in \mathbb{B} \ \forall i \in F, j \in C$: $x_{i,j} = 1$, якщо
>   клієнта $j$ обслуговує об’єкт $i$, і 0 інакше.
>
> **Цільова функція:**
>
> Мінімізувати сумарну вартість відкриття об’єктів та обслуговування клієнтів:
> $\min \sum_{i \in F} f_i \cdot y_i + \sum_{i \in F} \sum_{j \in C} c_{i,j} \cdot x_{i,j}.$
>
> **Обмеження:**
>
> 1. **Призначення клієнтів:** кожен клієнт має обслуговуватися рівно одним
>    відкритим об’єктом: $\sum_{i \in F} x_{i,j} = 1 \quad \forall j \in C.$
> 2. **Активація об’єкта:** клієнта можна обслуговувати об’єктом лише якщо він
>    відкритий: $x_{i,j} \leq y_i \quad \forall i \in F, j \in C.$

<!-- Математична модель є лаконічною та точною -->

Математична нотація настільки компактна, що її легко опрацьовувати на дошці чи
аркуші, і це ідеально підходить для групових обговорень. Така лаконічна й
точна форма також полегшує виявлення неузгодженостей або помилок, принаймні для
невеликих задач.

<!-- реалізація -->

Насамкінець ви реалізуєте модель у вибраному вами фреймворку оптимізації або
мові моделювання. У випадку навчальної вправи дуже ймовірно, що викладач уже
надав тестові інстанси, які можна використати для перевірки реалізації.

```python
from ortools.sat.python import cp_model

# 1. Parameters
F = [1, 2, 3]  # Set of potential facility locations.
C = [1, 2, 3]  # Set of customers.
f = {1: 100, 2: 200, 3: 150}  # Fixed cost f[i] of opening facility i.
c = {1: {1: 10, 2: 20, 3: 30},
     2: {1: 15, 2: 25, 3: 35},
     3: {1: 20, 2: 30, 3: 40}}  # Cost c[i][j] of serving customer j from facility i.

model = cp_model.CpModel()

# 2. Decision variables
y = {i: model.new_bool_var(f'y_{i}') for i in F}  # y[i] = 1 if facility i is opened.
x = {(i, j): model.new_bool_var(f'x_{i}_{j}') for i in F for j in C}  # x[i,j] = 1 if customer j is served by facility i.

# 3. Objective function
model.minimize(
    sum(f[i] * y[i] for i in F) + sum(c[i][j] * x[i, j] for i in F for j in C)
)
# 4. Constraints
for j in C:
    model.add(sum(x[i, j] for i in F) == 1)  # Each customer must be served by exactly one open facility.
for i in F:
    for j in C:
        model.add(x[i, j] <= y[i])  # A customer can only be served by a facility if that facility is open.

# Solve the model
solver = cp_model.CpSolver()
status = solver.solve(model)
# ...
```

<!-- класи замість функцій -->

Зазвичай це реалізують у вигляді функції; однак мені часто потрібно робити
моделі інкрементальними, що не сумісно зі статeless-функціями. До того ж
використання класів у Python майже так само просте, як і чистих функцій.
Можливість змінювати модель після побудови, наприклад фіксувати певні змінні,
також полегшує тестування та налагодження.

<!-- Приклад обгортання в клас. -->

Я б інкапсулював цей код у клас для підвищення повторного використання, і це
виглядало б приблизно так:

```python
class FacilityLocationModel:
    def __init__(self, F, C, f, c):
        self.F, self.C, self.f, self.c = F, C, f, c
        self.model = cp_model.CpModel()

        # 2. Decision variables
        self.y = {i: self.model.new_bool_var(f'y_{i}') for i in self.F}  # y[i] = 1 if facility i is opened.
        # ...

    def solve(self, **parameters):
        # Solve the model
        solver = cp_model.CpSolver()
        # ...
```

<!-- можна також прямо змоделювати в коді -->

Як бачите, реалізація майже ідентична математичній постановці, і багато
експертів можуть обрати пряме кодування, особливо при використанні мов
моделювання на кшталт Pyomo, GAMS чи AMPL.

<!-- працює і для багатьох практичних випадків, бо багато задач базові -->

На практиці багато випадків усе ще достатньо прості, щоб слідувати цьому
процесу. Хоча дані можуть бути недоступні одразу або вимагати суттєвої
передобробки, а постановка задачі ще не повністю визначена, часто можна
намалювати математичну постановку й одразу реалізувати її. Це особливо
можливо, бо багато задач по суті — добре відомі комбінаторні оптимізаційні
задачі, лише «замасковані» доменною термінологією. З досвідом можна швидко
розпізнати структуру проблеми й легко адаптувати її під нестандартні
обмеження.

<!-- ідеально для простих задач -->

Поки модель лишається такою простою, достатньо кількох базових тестів, щоб
переконатися, що розв’язки поводяться очікувано; немає потреби в модульності чи
розлогих функціях валідації. Таку модель легко зрозуміти і реалізувати за
кілька хвилин. Її можна показати на одному слайді, а додаткова структура радше
внесе зайву складність, ніж підвищить ясність.

<!-- від спрощувальної абстракції до незрозумілості, як техборг -->

Математична абстракція може спрощувати задачу, але також може стати настільки
абстрактною, що початкова проблема перестає бути впізнаваною. Поріг залежить
від бекграунду, але настає момент, коли монолітні формулювання стають
незрозумілими, а навіть незначні зміни вимагають значних зусиль. Якщо не можна
розглядати компоненти ізольовано, налагодження такої моделі стає надзвичайно
складним. Це схоже на архітектуру ПЗ, яка починалася просто, але через
інкрементальне зростання накопичила складність до рівня, де будь-яка зміна
ризикована, а швидкість розробки падає.

<!-- Приклади того, що може піти не так -->

Ось кілька речей, які можуть піти не так, коли модель стає надто складною:

- Ви єдина людина, яка розуміє модель, тому іншим її неможливо підтримувати.
- Навіть ви самі вже не повністю її розумієте, тож прості зміни займають
  вічність або ламають усе — і це часто виявляється лише в продакшні.
- Складність моделі не дозволяє перевіряти компоненти ізольовано, що робить
  аналіз першопричин дуже складним.
- Тестування стає непрактичним, і ви постійно сумніваєтеся в коректності моделі.
- Тонкий баг тихо відсікає якісні розв’язки, що призводить до значних втрат
  можливостей без явної помилки.
- Погані або неконсистентні дані не виявляються через відсутність валідації,
  породжуючи неправильні результати й підриваючи довіру до коду.
- Комунікація зі стейкхолдерами ламається, бо немає спільної мови для формального
  опису вимог.
- Модель стає настільки заплутаною, що реалізація всіх вимог — або навіть
  створення першого корисного прототипу — здається неможливою.
- Немає чітких інтерфейсів входу/виходу даних, що ускладнює співпрацю та
  інтеграцію.
- ...

<!-- Це збої на «простих» частинах -->

Усі ці проблеми можуть завалити проєкт ще до того, як ви дійдете до справжніх
викликів — оптимізації масштабованості та забезпечення точності в реальному
світі.

<!-- Огляд -->

Далі в цьому розділі ми розглянемо, як уникнути такої ситуації, застосувавши
практики інженерії ПЗ до оптимізаційних моделей на прикладі задачі графіка
медсестер. Ми виконаємо такі кроки:

1. **Схема даних:** визначити структуровані схеми для екземпляра задачі та
   розв’язку, охопивши параметри й частини простору рішень.
2. **Функції валідації:** реалізувати функції для перевірки здійсненності та
   обчислення значень цілі як формальну специфікацію.
3. **Змінні рішення:** ввести змінні рішення, інкапсульовані в контейнери, щоб
   спростити побудову обмежень і цілей.
4. **Модульні обмеження та цілі:** будувати обмеження й м’які цілі як незалежні,
   тестовані модулі.
5. **Інтеграція розв’язувача:** поєднати ці компоненти в повну CP-SAT модель і
   протестувати її в цілому, щоб перевірити спільну роботу компонентів.

<!-- не все або нічого -->

> [!TIP]
>
> Можна плавно переходити між двома підходами; це не вибір «усе або нічого».
> Цілком реально взяти лише частину описаного підходу й застосувати її до
> окремих аспектів задачі.

## Задача складання графіка медсестер

Перш ніж реалізовувати розв’язок, окреслимо задачу формування графіка медсестер
та її початкові вимоги. Задача
[nurse rostering problem](https://en.wikipedia.org/wiki/Nurse_scheduling_problem)
полягає у призначенні набору медсестер на зміни в межах визначеного горизонту
планування. Кожна зміна має заданий попит, що вказує мінімальну кількість
медсестер, необхідних для покриття. Мета — побудувати призначення, яке
задовольняє всі операційні обмеження, водночас оптимізуючи м’які вподобання
та пріоритети. У цьому прикладі вимоги такі:

**Обмеження (жорсткі вимоги):**

1. **Обмеження недоступності:** медсестру не можна призначати на зміну, якщо
   вона недоступна або явно заблокована.
2. **Вимога покриття зміни:** кожна зміна має бути укомплектована достатньою
   кількістю медсестер, щоб задовольнити попит.
3. **Обмеження періоду відпочинку:** медсестра має мати достатній відпочинок між
   послідовними змінами. Якщо інтервал між завершенням однієї зміни і початком
   наступної замалий, медсестру не можна призначати на обидві.

**Цілі (м’які вимоги):**

1. **Задоволення вподобань:** медсестри можуть вказувати уподобання щодо певних
   змін. Модель має враховувати ці вподобання, коли це можливо.
2. **Перевага штатного персоналу:** штатних працівників слід віддавати перевагу
   над зовнішніми чи контрактними медсестрами, якщо всі інші обмеження виконані.

Щоб первинна постановка була керованою, ми починаємо з цього обмеженого набору
обмежень і цілей. Реалізація спроєктована як **модульна та розширювана**,
щоб додаткові вимоги — такі як справедливість, стаж, чергування «on-call» та
інші — можна було додати пізніше з мінімальним рефакторингом. Хоч початкові
вимоги ще можна легко реалізувати монолітною моделлю, вона вже достатньо
складна, щоб показати переваги більш структурованого, тест-орієнтованого
підходу.

> [!WARNING]
>
> У цьому розділі головний фокус — коректність, а не продуктивність. Спершу
> переконайтеся, що розв’язок правильний; лише потім зосереджуйтеся на
> ефективності. Відповідно, реалізація тут може бути не найефективнішою.

## Схема екземпляра та розв’язку

<!-- Підручникові приклади припускають ідеальні дані; у реальному світі це рідкість -->

У академічних або підручникових прикладах часто починають із чистих,
добре структурованих даних, які ідеально відповідають задачі. У реальних
проєктах це трапляється рідко. Часто вже добре, якщо дані взагалі є — не кажучи
про те, що вони повні, узгоджені й готові до використання.

<!-- Дані можуть ще не існувати або бути лише на папері, чи бути неповними -->

Дані можуть ще не існувати в цифровому вигляді або все ще збиратися вручну —
можливо, навіть на папері. Навіть якщо цифрову систему вже розробляють, її ще
може не бути в продакшні, а наявні дані — застарілі або неповні. Питання
приватності чи юридичні обмеження можуть додатково обмежувати доступ до
критично важливої інформації, особливо коли йдеться про персональні дані, такі
як графіки медсестер.

> [!TIP]
>
> Отримайте зразок даних якомога раніше, навіть якщо це лише «обґрунтоване
> припущення» або невелика підмножина реального набору. Такі зразки полегшують
> виділення тестових кейсів і підтримують ітеративні обговорення зі
> стейкхолдерами, які часто не помічають дрібних, але важливих деталей.
> Наприклад, модель, розроблена тут, не обмежує одну зміну на день і натомість
> фокусується на періодах відпочинку та загальній кількості годин за період
> (наприклад, тиждень). Стейкхолдери, ймовірно, помітять такі прогалини, щойно
> переглянуть розв’язок для реалістичного інстансу. Виправлення таких проблем
> зазвичай вимагає гнучкого, ітеративного процесу — ми його тут опускаємо для
> простоти, але його можна застосовувати на всіх етапах цього прикладу.

<!-- Навіть доступні дані часто неузгоджені або ненадійні -->

І коли дані все ж надходять, вони часто приносять власні проблеми. Вони можуть
бути неповними, містити суперечливі записи або мати непослідовну структуру.
Excel лишається де-факто стандартом у багатьох організаціях, що несе ризики на
кшталт невідповідності типів, непослідовного форматування або зламаних формул.
Ще гірші — schemaless бази на кшталт Firestore, які не дають жодних гарантій
щодо структури чи узгодженості документів. Нерідко трапляються поля, які іноді
містять цілі числа, іноді рядки, а часом просто зникають — разом із ключами,
які можуть бути помилково написані, продубльовані або тихо втрачені.

<!-- Погані входи ламають ваш код, а не лише їхній -->

У такому середовищі будь-яка помилка в даних безпосередньо потрапляє у вашу
застосунок. Логіка ламається не тому, що модель неправильна, а тому, що
вхідні дані порушують припущення, про які ви навіть не здогадувалися.

<!-- Валідація схем і Pydantic як рішення -->

Після достатньої кількості розчарувань через погано сформовані дані я став
палким прихильником формальних схем даних як першого кроку в будь-якому
серйозному оптимізаційному проєкті. У Python чудовим інструментом для цього є
[Pydantic](https://docs.pydantic.dev/latest/): він дозволяє декларативно
визначати вхідні та вихідні схеми, автоматично перевіряє типи й інваріанти та
викидає зрозумілі помилки валідації, коли припущення порушуються. З такими
схемами проблеми можна ловити рано й легко діагностувати — задовго до того, як
вони спричинять неправильні результати або загадкові збої.

<!-- Схеми не лише для машин; вони прояснюють комунікацію команди -->

Визначення схеми також критично важливе, щоб усі учасники (включно з клієнтами)
однаково розуміли задачу. Ви можете використовувати однакові терміни — «зміна»,
«час початку», «тривалість» — але трактувати їх по-різному. Тривалість у
секундах, хвилинах чи годинах? «ID зміни» — це індекс чи зовнішній ключ у
окремій таблиці? Без точної схеми легко зробити небезпечні припущення.

<!-- Історичний приклад: Mars Climate Orbiter -->

Яскравий історичний приклад — втрата
[Mars Climate Orbiter](https://en.wikipedia.org/wiki/Mars_Climate_Orbiter)
у 1999 році. Космічний апарат було знищено, бо одна команда використовувала
імперські одиниці, а інша очікувала метричні, і між системами не було
забезпеченого контракту. Вся місія вартістю $327 млн провалилася через
непомітну невідповідність у спільному інтерфейсі даних. Хоч більшість
оптимізаційних проєктів не запускають космічні апарати, висновок такий самий:
ніколи не припускайте спільного розуміння — робіть припущення явними.

<!-- Почніть зі схем до написання логіки -->

Саме тому я волію визначати й документувати як вхідні, так і вихідні схеми на
початку проєкту — ще до першого рядка алгоритмічного коду. Це допомагає
формалізувати задачу, прояснює ролі різних полів і дозволяє всім рухатися до
однієї структури. Навіть якщо схема еволюціонує з часом (а це майже напевно
станеться), ця еволюція прозора, версіонована й легко керована.

<!-- Підсумок: схеми — основа -->

Нижче наведено схему даних, яку ми використаємо для задачі графіків медсестер.
Ми зробили два нетривіальні доповнення: `preferred_shift_weight` і
`staff_weight`. Навряд чи вони будуть частиною первинної постановки, але оскільки
в нас є дві цілі, це дозволить легко зважувати їх відносно одна одної. Можливо,
згодом ми вирішимо, що оптимізація має бути лексикографічною, і тоді ці ваги
стануть неважливими, але як стартовий крок корисно мати хоча б якийсь спосіб
балансувати дві цілі. Якщо потрібно додати більше параметрів (наприклад, вмикати
й вимикати обмеження), я б створив окремий клас
`NurseRosteringParameters` замість інтеграції таких параметрів у схему
екземпляра, але для простоти це опустимо.

```python
"""
This module defines the data schema for the nurse rostering problem.
Note that this is just a random variant of the nurse rostering problem.

We define the instance and solution data structures using Pydantic.
"""

from datetime import datetime, timedelta
from pydantic import BaseModel, Field, NonNegativeInt, model_validator, PositiveInt
import uuid

# Semantic type aliases for clarity
NurseUid = int
ShiftUid = int


def generate_random_uid() -> int:
    # Use uuid4 and convert to an integer (truncated to 64 bits for practical use)
    return uuid.uuid4().int >> 64


class Nurse(BaseModel):
    """
    Represents a nurse whose shifts we want to plan. Will be part of `NurseRosteringInstance`.
    """
    uid: NurseUid = Field(
        default_factory=generate_random_uid,
        description="Unique identifier for the nurse",
    )
    name: str = Field(..., description="Name of the nurse")
    preferred_shifts: set[ShiftUid] = Field(
        ..., description="List of preferred shift UIDs for the nurse"
    )
    blocked_shifts: set[ShiftUid] = Field(
        ..., description="List of blocked shift UIDs for the nurse"
    )
    staff: bool = Field(
        ...,
        description="Indicates if the nurse is a staff member (True) or a contractor (False)",
    )
    min_time_between_shifts: timedelta = Field(
        ..., description="Minimum off duty time between two shifts for the same nurse"
    )
    preferred_shift_weight: NonNegativeInt = Field(
        default=1,
        description="The weight in the objective function for every assigned preference.",
    )


class Shift(BaseModel):
    """
    Represents a shift that needs to be covered by nurses. Will be part of `NurseRosteringInstance`.
    """
    uid: ShiftUid = Field(
        default_factory=generate_random_uid,
        description="Unique identifier for the shift",
    )
    name: str = Field(..., description="Name of the shift (e.g., '2025-01-01 Morning')")
    start_time: datetime = Field(
        ..., description="Start time of the shift as a full datetime (YYYY-MM-DD HH:MM)"
    )
    end_time: datetime = Field(..., description="End time of the shift as a full datetime (YYYY-MM-DD HH:MM)")
    demand: NonNegativeInt = Field(
        ..., description="Number of nurses required for this shift"
    )

class NurseRosteringInstance(BaseModel):
    """
    This schema defines the INPUT for the nurse rostering problem.
    """
    nurses: list[Nurse] = Field(
        ..., description="List of nurses in the rostering instance"
    )
    shifts: list[Shift] = Field(
        ...,
        description="List of shifts that need to be covered. Shifts must be sorted in time.",
    )
    staff_weight: int = Field(
        default=1,
        description="The weight in the objective function for each assigned staff nurse.",
    )

    @model_validator(mode="after")
    def validate_shifts_unique_uids(self):
        """
        Ensure that all shifts have unique UIDs to avoid conflicts.
        """
        shift_uids = {shift.uid for shift in self.shifts}
        if len(shift_uids) != len(self.shifts):
            raise ValueError("Shift UIDs must be unique.")
        return self

    @model_validator(mode="after")
    def validate_nurses_unique_uids(self):
        """
        Ensure that all nurses have unique UIDs to avoid conflicts.
        """
        nurse_uids = {nurse.uid for nurse in self.nurses}
        if len(nurse_uids) != len(self.nurses):
            raise ValueError("Nurse UIDs must be unique.")
        return self

    @model_validator(mode="after")
    def validate_shifts_sorted_by_time(self):
        """
        Ensure that shifts are sorted by start time.
        """
        for shift_a, shift_b in zip(self.shifts, self.shifts[1:]):
            if shift_a.start_time > shift_b.start_time:
                raise ValueError("Shifts must be sorted by start time.")
        return self
```

<!-- Схема розв’язку та Pydantic vs нативні списки -->

У розв’язку кожна зміна відображається у список призначених медсестер. Також
зберігаються значення цільової функції та час, коли розв’язок обчислено. Як
покращення структуру `list[NurseUid]` можна замінити окремою Pydantic-моделлю.
Це дозволить у майбутньому додавати додаткові дані для конкретної зміни, які
неможливо прямо прикріпити до звичайного `list`. Такий дизайн особливо корисний,
коли розв’язок потрібно відображати в інтерфейсі користувача. Водночас, якщо
базовий об’єкт — Pydantic-модель, зазвичай можна зберігати зворотну сумісність
під час розширення схеми навіть тоді, коли вона містить нативні елементи Python.

```python
class NurseRosteringSolution(BaseModel):
    """
    This schema defines the OUTPUT for the nurse rostering problem.
    """
    nurses_at_shifts: dict[ShiftUid, list[NurseUid]] = Field(
        ..., description="Maps shift UIDs to lists of assigned nurse UIDs."
    )
    objective_value: int = Field(
        description="Objective value of the computed solution."
    )
    timestamp: datetime = Field(
        default_factory=datetime.now,
        description="Time when the solution was generated. Takes little space and can be extremely useful when investigating issues with the solution. Optimally, also add the revision of the algorithm that generated the solution, e.g., by using a git commit hash.",
    )
    # Validation of the solution will be handled in a separate module.
```

Із цими схемами одразу стає зрозуміло, якої структури мають дотримуватися вхідні
та вихідні дані. Методи `model_validator` дозволяють закодувати важливі
припущення — наприклад, унікальність чи впорядкування — і піднімати явні
помилки, якщо припущення порушуються. Хоч це й не гарантує, що всі дані
абсолютно правильні, воно запобігає багатьом випадковим помилкам і значно
полегшує налагодження. Перехоплюючи проблеми на межі, ви отримуєте впевненість,
що оптимізаційна логіка працює з коректно сформованими входами.

> [!TIP]
>
> Вам не обов’язково використовувати одну й ту саму схему для контракту
> ендпойнта та внутрішнього представлення оптимізаційної моделі. Перетворення
> між різними схемами дешево порівняно з вартістю розв’язання моделі. Якщо інше
> представлення дозволяє ефективніше будувати модель, додайте додатковий шар.
> Пам’ятайте: внутрішню схему можна змінювати легко, а зміни у зовнішній схемі
> треба робити обережно, щоб не зламати існуючі інтерфейси.

### Табличні дані

<!-- Табличні дані поширені й зручні, якщо вони чисті -->

Багато людей, включно зі мною, цінують роботу з таблицями. У прикладі цього
розділу ми використовуємо вкладену структуру даних. Втім, у багатьох проєктах
табличні дані цілком достатні, і в таких випадках краще віддавати перевагу
саме такому поданню. В принципі, будь-яку структуру даних можна подати у
табличному вигляді, а більшість поширених баз даних, зокрема реляційні бази
через SQL, побудовані навколо таблиць. Проте, коли для отримання інформації
потрібні складні джойни або агрегації, може знадобитися або перебудувати
таблиці, або перейти до більш об’єктного формату, наприклад, до Pydantic-моделей,
як показано вище. Оскільки під час побудови моделі вхідні дані не слід
модифікувати, цілком прийнятно використовувати обидва представлення паралельно.

Якщо дані природно та інтуїтивно виражаються у табличному вигляді, варто
зберегти саме таке представлення. Python має чудові бібліотеки для роботи з
табличними даними, зокрема [Pandas](https://pandas.pydata.org/) і
[Polars](https://www.pola.rs/). Pandas — найпоширеніша бібліотека для аналізу
даних у Python із багатою екосистемою розширень та інтеграцій. Водночас у неї
є обмеження продуктивності, особливо на великих датасетах. Polars — новіша
бібліотека, орієнтована на продуктивність. Оскільки оптимізаційні задачі
зазвичай працюють із набагато меншими наборами даних, ніж аналітика чи ML,
широке використання й екосистема Pandas часто роблять її більш доцільним вибором.

Головна перевага зберігання даних у Pandas DataFrame — можливість виконувати
агрегації, фільтрацію та трансформації лаконічним і виразним синтаксисом.
Крім того, Pandas добре інтегрується з бібліотеками візуалізації, такими як
[Matplotlib](https://matplotlib.org/) і [Seaborn](https://seaborn.pydata.org/),
які дозволяють легко створювати інформативні візуальні представлення даних.

Хочете масштабувати колонку до діапазону [0, 1]? Для цього потрібен лише один
рядок коду:

```python
df['scaled_column'] = (df['column'] - df['column'].min()) / (df['column'].max() - df['column'].min())
```

Хочете відфільтрувати рядки за умовою? Це теж робиться в один рядок:

```python
filtered_df = df[df['column'] > threshold]
```

CP-SAT також інтегрується з Pandas, як показано в наступному прикладі задачі
рюкзака, де значення і ваги предметів зберігаються у `DataFrame`:

```python
from ortools.sat.python import cp_model
import pandas as pd

# Example data: each row is an item with a weight and a value
# In production, you would likely load this from a file or database,
# which pandas has simple loaders for.
df = pd.DataFrame(
    data={
        "weight": [2, 4, 3, 5, 1, 6, 2, 7, 3, 4],
        "value": [10, 8, 7, 6, 5, 9, 4, 3, 2, 1],
    },
    index=["A", "B", "C", "D", "E", "F", "G", "H", "I", "J"],
)

model = cp_model.CpModel()

# Create a Boolean variable for each item (indexed by DataFrame index)
x = model.new_bool_var_series("x", df.index)

# Use Pandas vectorized operations to build constraints and objectives
model.add((x @ df["weight"]) <= 15)  # total weight limit
model.maximize(x @ df["value"])      # maximize total value
```

Деякі обмеження зручно додавати построчно. Наприклад, уявімо набір заборонених
пар предметів, які не можна вибирати разом. Такі обмеження природно подати як
двоколонкову таблицю:

```python
prohibited_pairs_df = pd.DataFrame(
    data={
        "item1": ["A", "B", "C"],
        "item2": ["D", "E", "F"],
    }
)

# For each row, apply the corresponding constraint
for _, row in prohibited_pairs_df.iterrows():
    model.add(x[row["item1"]] + x[row["item2"]] <= 1)
```

Припустімо, що ми маємо не лише заборонені пари, а довільні набори предметів,
які не можна вибирати разом. Щоб виразити це у класичному табличному форматі,
ми введемо унікальний ідентифікатор для кожного набору й таблицю зв’язків, яка
відображає ідентифікатори предметів на ідентифікатори наборів. Для побудови
обмежень ми спершу згрупуємо рядки за ідентифікатором набору, агрегуємо
відповідні ідентифікатори предметів, а потім додамо обмеження для кожного
набору. Якщо ця вимога — лише мала частина моделі, табличний підхід прийнятний.
Однак, якщо модель спирається на багато таких наборів чи списків, я рекомендую
переходити до більш об’єктного представлення, як у задачі графіків медсестер у
цьому розділі.

Працюючи з табличними даними, все одно важливо забезпечити строгі схеми, як ми
робили це з Pydantic-моделями вище. Це можна реалізувати за допомогою бібліотек
на кшталт [pandera](https://pandera.readthedocs.io/en/stable/). Наприклад, ми
можемо вимагати, щоб ваги і значення предметів були невід’ємними цілими числами.
Хоч це й здається тривіальним, помилки легко виникають, наприклад, коли дані
витягуються з поширених Excel-файлів десь у ланцюгу обробки.

```python
import pandas as pd
import pandera.pandas as pa

schema = pa.DataFrameSchema({
    "weight": pa.Column(int, pa.Check.ge(0)),
    "value": pa.Column(int, pa.Check.ge(0)),
})

validated_df = schema.validate(df)
```

> :reference:
>
> Princeton Consultants мають чудовий допис про
> [Rapid Optimization Model Development with Python and pandas in 7 Steps](https://princetonoptimization.com/blog/rapid-optimization-model-development-python-and-pandas-7-steps/),
> який детальніше розглядає процес побудови моделей з Pandas. У своїй практиці я
> часто працюю з проєктами, де дані більш графові або ієрархічні, і в таких
> випадках Pydantic є природнішим представленням для побудови оптимізаційних
> моделей. Я спеціально додав цю підсекцію, щоб підкреслити: використання
> вкладених даних з Pydantic — не єдиний і не завжди найкращий підхід. Зрештою,
> потрібно обрати представлення, яке найкраще відповідає вашим даним і вашій
> команді. За потреби можна використовувати кілька представлень паралельно, адже
> додаткові витрати пам’яті зазвичай незначні.

## Валідація, незалежна від розв’язувача

<!-- Раннє написання функцій валідації прояснює обмеження і вмикає TDD -->

Маючи визначені схеми даних, ми можемо реалізувати функції валідації, які
перевіряють, чи запропонований розв’язок задовольняє всі обмеження. Це перший
конкретний крок до робочого процесу на основі тестів.

<!-- Підкреслює цінність валідації для синхронізації зі стейкхолдерами -->

Ці функції валідації не залежать від розв’язувача, тобто не спираються на
конкретний алгоритм або бібліотеку на кшталт CP-SAT. Це робить їх ідеальними для
комунікації та перевірки специфікації разом із доменними експертами чи
клієнтами. Ба більше, людина з базовими навичками програмування може прочитати
чи навіть доповнити такі перевірки, зменшуючи непорозуміння щодо вимог.

<!-- Прояснює, що явне визначення цілі — великий крок уперед -->

Окрім здійсненності, тут же визначаємо й цільову функцію. Це може здаватися
незвичним для логіки валідації, але дає чітку й однозначну специфікацію того,
що саме ми оптимізуємо. На практиці цільова функція часто є наймінливішою
частиною специфікації — її переглядають, коли додаються нові цілі, витрати чи
стимули. Виражаючи її у коді, ми полегшуємо спільне обговорення й ітерації.

> :warning:
>
> Створення ефективної цільової функції потребує досвіду. Я часто бачив, як менш
> досвідчені практики робили неправильні висновки щодо її правильної постановки.
> Поширені помилки — ненавмисне кодування частин цілі як обмежень або визначення
> цілі так, що це дозволяє небажані компроміси між її компонентами. Якщо клієнт
> надає цільову функцію, не реалізуйте її сліпо — спершу ретельно проаналізуйте.

<!-- Підсумовує переваги -->

Пишучи ці перевірки заздалегідь, ми робимо задачу точною й виконуваною. Навіть
без оптимізаційного рушія ми вже знаємо, як відрізнити валідні розв’язки від
невалідних і як порівнювати два здійсненні розв’язки за якістю. Це дає нам
міцну основу для розробки та тестування оптимізаційних алгоритмів у наступних
кроках. Якщо пощастить, це навіть може бути циклом зворотного зв’язку для
AI-асистента, який напише розв’язок за нас, хоча мій досвід тут поки змішаний.

Наступний модуль Python надає ці перевірки валідації та функцію для обчислення
значення цілі:

```python
"""
This module contains validation functions for nurse rostering solutions.
It is solver and algorithm agnostic, meaning it can be used to validate solutions
from any solver that produces a `NurseRosteringSolution` object. Just by providing
such functions, you have taken a huge step toward computing a solution, as you now
have a clean specification of what a valid and good solution looks like.
"""

from collections import defaultdict
from .data_schema import NurseRosteringInstance, NurseRosteringSolution


def assert_consistent_uids(
    instance: NurseRosteringInstance, solution: NurseRosteringSolution
):
    """
    Assert that all UIDs in the solution are part of the instance.
    """
    nurse_uids = {n.uid for n in instance.nurses}
    shift_uids = {s.uid for s in instance.shifts}
    for shift_uid, nurse_list in solution.nurses_at_shifts.items():
        if shift_uid not in shift_uids:
            raise AssertionError(f"Shift {shift_uid} is not present in the instance.")
        for nurse_uid in nurse_list:
            if nurse_uid not in nurse_uids:
                raise AssertionError(
                    f"Nurse {nurse_uid} is not present in the instance."
                )


def assert_no_blocked_shifts(
    instance: NurseRosteringInstance, solution: NurseRosteringSolution
):
    """
    Assert that no nurse is assigned to a blocked shift in the solution.
    """
    for nurse in instance.nurses:
        for shift_uid in nurse.blocked_shifts:
            if (
                shift_uid in solution.nurses_at_shifts
                and nurse.uid in solution.nurses_at_shifts[shift_uid]
            ):
                raise AssertionError(
                    f"Nurse {nurse.uid} is assigned to blocked shift {shift_uid}."
                )


def assert_demand_satisfaction(
    instance: NurseRosteringInstance, solution: NurseRosteringSolution
):
    """
    Assert that each shift meets its nurse demand.
    """
    for shift in instance.shifts:
        assigned = solution.nurses_at_shifts.get(shift.uid, [])
        if len(assigned) < shift.demand:
            raise AssertionError(
                f"Shift {shift.uid} demand not met: {len(assigned)}/{shift.demand} assigned."
            )


def assert_min_time_between_shifts(
    instance: NurseRosteringInstance, solution: NurseRosteringSolution
):
    """
    Assert that nurses are not assigned to shifts too close together.
    """
    shifts_by_uid = {s.uid: s for s in instance.shifts}
    nurse_to_shifts = defaultdict(list)
    for shift_uid, nurse_uids in solution.nurses_at_shifts.items():
        for nurse_uid in nurse_uids:
            nurse_to_shifts[nurse_uid].append(shifts_by_uid[shift_uid])
    for nurse in instance.nurses:
        assigned = sorted(nurse_to_shifts[nurse.uid], key=lambda s: s.start_time)
        for a, b in zip(assigned, assigned[1:]):
            if b.start_time < a.end_time + nurse.min_time_between_shifts:
                raise AssertionError(
                    f"Nurse {nurse.uid} assigned to shifts {a.uid} and {b.uid} with insufficient rest."
                )


def objective_value(
    instance: NurseRosteringInstance, solution: NurseRosteringSolution
) -> int:
    """
    Calculate the objective value of the solution based on the instance's preferences and staff assignments.
    """
    nurses_by_uid = {n.uid: n for n in instance.nurses}
    obj_val = 0
    for shift_uid, nurse_uids in solution.nurses_at_shifts.items():
        for nurse_uid in nurse_uids:
            nurse = nurses_by_uid[nurse_uid]
            if shift_uid in nurse.preferred_shifts:
                # Preferred shifts decrease the objective (we minimize).
                obj_val -= nurse.preferred_shift_weight
            if not nurse.staff:
                # Non-staff nurses incur a penalty (they are more expensive).
                obj_val += instance.staff_weight
    return obj_val


def assert_solution_is_feasible(
    instance: NurseRosteringInstance,
    solution: NurseRosteringSolution,
    check_objective: bool = True,
):
    """
    Run all standard feasibility checks.
    """
    assert_consistent_uids(instance, solution)
    assert_no_blocked_shifts(instance, solution)
    assert_demand_satisfaction(instance, solution)
    assert_min_time_between_shifts(instance, solution)
    if check_objective:
        obj_val = objective_value(instance, solution)
        if obj_val != solution.objective_value:
            raise AssertionError(
                f"Objective value mismatch: expected {obj_val}, got {solution.objective_value}."
            )
```

<!-- Функції валідації незалежні від розв’язувача та пріоритизують ясність -->

Головна перевага цих функцій валідації — вони повністю незалежні від будь-якого
розв’язувача чи оптимізаційної моделі. Це означає, що нам не потрібно
оптимізувати їхню продуктивність — вони мають бути правильними, зрозумілими та
легкими для читання. Точні й інформативні повідомлення про помилки критично
важливі, адже саме вони підкажуть, що пішло не так, коли тести падають.

<!-- Валідація особливо цінна для складних задач -->

Для простих задач такий рівень валідації може здаватися надмірним, особливо
тому, що CP-SAT уже використовує декларативний стиль моделювання. Проте ці
функції дають незалежну специфікацію задачі, що допомагає рано виявляти
непорозуміння та приховані припущення.

<!-- Валідація і CP-SAT доповнюють одна одну -->

Для складніших задач ці функції валідації часто простіші та інтуїтивніші за
відповідні обмеження CP-SAT. Наприклад, при мінімальному часі відпочинку між
змінами логіка валідації прямо перевіряє порушення, тоді як CP-SAT кодує
допустимі шаблони призначень. У цьому сенсі валідація і CP-SAT доповнюють
одна одну: одна визначає, що неправильно, інша — що дозволено.

<!-- Дозволяє повністю змінити оптимізаційний алгоритм -->

Нарешті, цілком можливо, що чиста CP-SAT модель не масштабуватиметься
достатньо, попри всі оптимізації, і тоді доведеться декомпозувати задачу. Ці
функції валідації залишаться корисними й захистять вас, наприклад, коли ви
замінюєте базову CP-SAT модель на large neighborhood search чи метаевристичний
підхід.

> [!TIP]
>
> Ви також можете додати юніт-тести для цих функцій валідації, щоб переконатися,
> що вони піднімають очікувані помилки для некоректних входів. Однак у більшості
> випадків я вважаю це зайвим, адже комплементарність функцій валідації та
> обмежень CP-SAT, імовірно, виявить більшість несумісностей. Якщо тест падає,
> завжди перевіряйте, чи сам тест випадково не неправильний.

## Змінні рішення

<!-- Перехід від специфікації до моделювання -->

До цього моменту ми визначили **параметри** задачі (через Pydantic-схеми) й
створили **функції валідації**, що служать незалежною від розв’язувача
специфікацією обмежень і цілей. Ці функції по суті описують, як має виглядати
валідний розв’язок і як вимірюється його якість.

<!-- Мотивація для моделі CP-SAT -->

Наступний крок — перетворити цю високорівневу специфікацію на формальну
оптимізаційну модель у CP-SAT. Для цього ми починаємо з визначення **змінних
рішення**, які представляють основні вибори задачі. Для графіка медсестер
природна змінна рішення така:

> **Чи призначена медсестра $i$ на зміну $j$?**

Її можна представити бінарною змінною $x_{i,j}$, яка дорівнює true, якщо
медсестра $i$ працює зміну $j$, і false — інакше.

<!-- Контейнер змінних як шаблон проєктування -->

Замість того щоб керувати цими змінними як сирим двовимірним масивом, ми
структуруємо їх у **контейнери змінних**. Для кожної медсестри створюємо
контейнер, який містить змінні призначень і надає зручні методи для підрахунку
змін, ітерації по призначеннях та витягування розв’язку. Такий підхід зберігає
модель модульною, спрощує реалізацію обмежень і підтримує повторне використання
при додаванні нових обмежень чи цілей.

```python
"""
This module provides a basic container to manage the variables for a single nurse in the nurse rostering problem.
"""

from collections.abc import Iterable
from ortools.sat.python import cp_model
from .data_schema import Nurse, Shift, ShiftUid


class NurseDecisionVars:
    """
    A container to create and manage the decision variables for a single nurse.

    Each nurse has one Boolean variable for each shift, indicating whether the nurse is assigned to that shift.
    This class also provides helper methods to iterate over assignments and extract results.
    """

    def __init__(self, nurse: Nurse, shifts: list[Shift], model: cp_model.CpModel):
        self.nurse = nurse
        self.shifts = shifts
        self.model = model
        # Create one Boolean decision variable per shift for this nurse
        self._x = {
            shift.uid: model.new_bool_var(f"assign_{nurse.uid}_{shift.uid}")
            for shift in shifts
        }

    def fix(self, shift_uid: ShiftUid, value: bool):
        """
        Fix the assignment variable for the given shift UID to a specific value (True or False).
        Useful for setting hard constraints or testing the model.
        """
        if shift_uid not in self._x:
            raise ValueError(
                f"Shift UID {shift_uid} not found in nurse {self.nurse.uid} assignments."
            )
        self.model.add(self._x[shift_uid] == value)

    def is_assigned_to(self, shift_uid: ShiftUid) -> cp_model.BoolVarT:
        """
        Return the decision variable for the given shift UID.
        This variable is True if the nurse is assigned to that shift, and False otherwise.
        """
        return self._x[shift_uid]

    def iter_shifts(self) -> Iterable[tuple[Shift, cp_model.BoolVarT]]:
        """
        Iterate over all (shift, variable) pairs for this nurse.
        """
        for shift in self.shifts:
            yield shift, self.is_assigned_to(shift_uid=shift.uid)

    def extract(self, solver: cp_model.CpSolver) -> list[ShiftUid]:
        """
        Extract a list of shift UIDs that this nurse is assigned to in the solution.
        """
        return [shift_uid for shift_uid in self._x if solver.value(self._x[shift_uid])]
```

<!-- Дозволяє рефакторинг і оптимізаційні трюки -->

Інкапсулюючи змінні рішення таким чином, ми спрощуємо процес побудови обмежень
і цілей. Кожен модуль обмежень може зосередитися на одній медсестрі або підмножині
змін, не занурюючись у низькорівневі деталі створення змінних чи індексації.
Поведінку класу `NurseDecisionVars` можна згодом змінити, наприклад, щоб не
створювати змінні для змін, нерелевантних конкретній медсестрі, і повертати
константу `0`, коли такі зміни запитуються. Такі зміни також можна пропускати в
`iter_shifts`, щоб підвищити ефективність циклів. Подібний рефакторинг простий
за контейнерного дизайну, але значно складніший при використанні, наприклад,
сирого двовимірного масиву.

## Модулі

<!-- Вступ до модульного дизайну -->

Тепер, коли ми визначили змінні рішення, наступний крок — перенести обмеження й
цілі у оптимізаційну модель. Для задачі графіка медсестер є кілька логічно
незалежних обмежень. Замість того щоб писати їх у монолітному скрипті розв’язувача,
ми реалізуємо кожне обмеження або ціль як окремий **модуль**.

<!-- Чому модульність цінна -->

Такий модульний підхід дає кілька переваг:

- Модель лишається організованою та читабельною.
- Кожен модуль можна тестувати окремо (що відповідає підходу TDD).
- Додавати, вилучати чи змінювати обмеження або цілі згодом дуже просто — досить
  додати чи замінити модуль.

<!-- Вступ до абстрактного базового класу -->

Щоб усі модулі дотримувалися однакової структури, ми визначаємо **абстрактний
базовий клас**, який задає інтерфейс реалізації обмежень і цілей. Цей клас має
єдиний метод `build`, що застосовує обмеження модуля і, за потреби, повертає
підцільовий вираз. Ці підцілі згодом об’єднуються в глобальну цільову функцію.

<!-- Зв’язок із змінними рішення -->

Метод `build` приймає три аргументи:

1. **Екземпляр**, що містить параметри задачі.
2. **Модель CP-SAT**, яку ми модифікуємо, додаючи обмеження.
3. Список **контейнерів змінних рішення** (по одному на медсестру), що дає
   зручний доступ до змінних, пов’язаних із цією медсестрою.

<!-- Пояснення коду -->

Ось абстрактний базовий клас для всіх модулів:

```python
import abc
from ortools.sat.python import cp_model
from .data_schema import NurseRosteringInstance
from .nurse_vars import NurseDecisionVars


class ShiftAssignmentModule(abc.ABC):
    @abc.abstractmethod
    def build(
        self,
        instance: NurseRosteringInstance,
        model: cp_model.CpModel,
        nurse_shift_vars: list[NurseDecisionVars],
    ) -> cp_model.LinearExprT:
        """
        Apply the constraints and return an optional sub-objective expression.
        Subclasses must implement this method to define their specific constraints and objectives.
        """
        return 0
```

Для тестування ми використаємо кілька допоміжних класів, які суттєво зменшують
boilerplate-код під час валідації CP-SAT моделей. Ці утиліти дають інтуїтивний
спосіб перевірити, чи модель є здійсненною або ні після додавання обмежень.

Ці утиліти можна встановити через `pip install cpsat-utils`

```python
from cpsat_utils.testing import (
    AssertModelFeasible,
    AssertModelInfeasible,
    assert_objective,
)

with AssertModelFeasible() as model:
    # build a model that is supposed to be feasible
    # if the model is infeasible, the context manager will raise an error

with AssertModelInfeasible() as model:
    # build a model that is supposed to be infeasible
    # if the model is feasible, the context manager will raise an error

# assert that the model is feasible and has the expected objective value
assert_objective(model=model, expected=-1.0)
```

Ці утиліти особливо корисні для **test-driven development (TDD)**, адже вони
роблять тести лаконічними й зосередженими на **тому, що має відбутися**, а не на
механіці розв’язання та перевірки моделі. Обгортаючи логіку розв’язувача у
контекст-менеджер, ви уникаєте повторюваного налаштування і робите тести
читабельнішими та легшими в підтримці.

Ми писатимемо тести з використанням [**pytest**](https://docs.pytest.org/en/stable/),
широко вживаного фреймворку тестування для Python. У pytest достатньо писати
функції, що починаються з `test_`, і фреймворк автоматично їх знайде й виконає.
Щоб запустити всі тести, просто введіть `pytest` у терміналі — він знайде всі
тестові файли (названі `test_*.py` або `*_test.py`) і виконає тести в них.

Ось мінімальний приклад:

```python
# ./tests/test_example.py

def test_example():
    """
    This is a simple example test that always fails.
    Use it to verify that your testing framework is set up correctly.
    """
    assert False  # Make sure you get an error here to confirm the test framework is working.
```

Щоб отримати прості тестові дані, ми також напишемо кілька простих функцій
генерації даних.

1. **create_shifts**: генерує список змін із послідовними часами початку.
2. **create_nurse**: створює медсестру із заданим іменем та заблокованими змінами.

Код досить простий, його наведено нижче:

<details><summary>Натисніть, щоб розгорнути код генерації даних</summary>

```python
# ./tests/generate.py
"""
A simple utility to create shifts and nurses for testing purposes.
"""

from datetime import datetime, timedelta
from nurserostering.data_schema import Shift, Nurse


def create_shifts(k: int, week: int = 0, shift_length: int = 8) -> list[Shift]:
    """
    Create a list of shifts for testing.
    Each shift is named "Shift {i}" and has a start time and end time.
    """
    shifts = []
    for i in range(k):
        start_time = (
            datetime(2025, 1, 1, 0, 0)
            + timedelta(hours=i * shift_length)
            + timedelta(days=week * 7)
        )
        end_time = (
            datetime(2025, 1, 1, 0, 0)
            + timedelta(hours=(i + 1) * shift_length)
            + timedelta(days=week * 7)
        )
        shifts.append(
            Shift(
                name=f"Shift {i + 1}",
                start_time=start_time,
                end_time=end_time,
                demand=2,
            )
        )
    return shifts


def create_nurse(
    nurse_name: str = "Test Nurse",
    preferred_shifts: set[int] | None = None,
    blocked_shifts: set[int] | None = None,
    staff: bool = True,
    min_time_between_shifts: timedelta = timedelta(hours=8),
) -> Nurse:
    """
    Create a nurse with customizable attributes.
    """
    if preferred_shifts is None:
        preferred_shifts = set()
    if blocked_shifts is None:
        blocked_shifts = set()
    return Nurse(
        name=nurse_name,
        preferred_shifts=preferred_shifts,
        blocked_shifts=blocked_shifts,
        staff=staff,
        min_time_between_shifts=min_time_between_shifts,
    )
```

</details>

### Без заблокованих змін

Коли ми починаємо реалізовувати обмеження, мудро стартувати з найпростішого
правила. Для задачі графіка медсестер таким правилом є те, що **медсестру не
можна призначати на зміну, якщо вона явно заблокована для цієї зміни.** Це
моделює відпустки, лікарняні чи інші форми недоступності. Якщо це обмеження
порушено, графік невалідний, незалежно від інших якостей.

Тепер застосуємо підхід TDD, щоб реалізувати це обмеження.

#### Крок 1: написання першого тесту (тривіальна здійсненність)

Перший тест перевіряє тривіальний випадок: медсестра **без заблокованих змін**
не повинна спричиняти не здійсненність. У цьому випадку навіть не потрібно
фіксувати жодних призначень. Мета — переконатися, що модель лишається
валідною, коли обмеження ще не накладені.

```python
def test_no_blocked_shifts_trivial():
    """
    A nurse with no blocked shifts should always lead to a feasible model.
    """
    shifts = create_shifts(2)  # two consecutive shifts
    nurse = create_nurse("Nurse A", blocked_shifts=set())
    instance = NurseRosteringInstance(nurses=[nurse], shifts=shifts)

    with AssertModelFeasible() as model:
        nurse_vars = NurseDecisionVars(nurse, shifts, model)
        NoBlockedShiftsModule().build(instance, model, [nurse_vars])
```

Цей тест, звісно, впаде, бо ми ще не реалізували `NoBlockedShiftsModule`.
Зробімо це далі.

```python
class NoBlockedShiftsModule(ShiftAssignmentModule):
    """
    Prohibit assignment to blocked shifts.
    """

    def build(
        self,
        instance: NurseRosteringInstance,
        model: cp_model.CpModel,
        nurse_shift_vars: list[NurseDecisionVars],
    ) -> cp_model.LinearExprT:
        # TODO
        return 0
```

Тепер він має пройти, бо насправді ми ще не накладаємо жодних обмежень.
Створімо другий тест, який перевіряє, що ми не можемо призначити медсестру на
зміну, для якої вона заблокована.

#### Крок 2: перевірка не здійсненності для заблокованих змін

Якщо медсестра **заблокована для зміни**, але ми примусово призначаємо її на
цю зміну, модель має стати не здійсненною. Це підтверджує, що обмеження
справді запобігає невалідним призначенням.

```python
def test_no_blocked_shifts_infeasible():
    """
    The model should be infeasible if we assign a nurse to a blocked shift.
    """
    shifts = create_shifts(2)
    nurse = create_nurse("Nurse A", blocked_shifts={shifts[0].uid})
    instance = NurseRosteringInstance(nurses=[nurse], shifts=shifts)

    with AssertModelInfeasible() as model:
        nurse_vars = NurseDecisionVars(nurse, shifts, model)
        NoBlockedShiftsModule().build(instance, model, [nurse_vars])
        nurse_vars.fix(shifts[0].uid, True)  # Force assignment to a blocked shift
```

Цей тест тепер має падати, бо ми ще не реалізували логіку, що забезпечує
обмеження заблокованих змін. Реалізуємо її в `NoBlockedShiftsModule`.

```python
class NoBlockedShiftsModule(ShiftAssignmentModule):
    """
    Prohibit assignment to blocked shifts.
    """

    def enforce_for_nurse(self, model: cp_model.CpModel, nurse_x: NurseDecisionVars):
        for shift_uid in nurse_x.nurse.blocked_shifts:
            # Prohibit assignment to blocked shifts
            model.add(nurse_x.is_assigned_to(shift_uid=shift_uid) == 0)

    def build(
        self,
        instance: NurseRosteringInstance,
        model: cp_model.CpModel,
        nurse_shift_vars: list[NurseDecisionVars],
    ) -> cp_model.LinearExprT:
        for nurse_x in nurse_shift_vars:
            self.enforce_for_nurse(model, nurse_x)
        return 0  # no objective contribution
```

#### Крок 3: перевірка здійсненності на незаблокованих змінах

Нарешті, перевіримо, що медсестра може працювати на **інших, незаблокованих
змінах**. Тут ми призначаємо медсестру на дозволену зміну й очікуємо, що
модель залишиться здійсненною.

```python
def test_no_blocked_shifts_feasible():
    """
    A nurse assigned to a non-blocked shift should remain feasible.
    """
    shifts = create_shifts(2)
    nurse = create_nurse("Nurse A", blocked_shifts={shifts[0].uid})
    instance = NurseRosteringInstance(nurses=[nurse], shifts=shifts)

    with AssertModelFeasible() as model:
        nurse_vars = NurseDecisionVars(nurse, shifts, model)
        NoBlockedShiftsModule().build(instance, model, [nurse_vars])
        nurse_vars.fix(shifts[1].uid, True)  # Assign allowed shift
```

Наш `NoBlockedShiftsModule` має покривати і цей випадок. У наступних модулях ми
не будемо детально проходити цикл TDD, але все одно опишемо ключові тести й
реалізацію кожного модуля. Так ми збережемо фокус на обмеженнях і цілях, а не
на механіці тестування.

> [!TIP]
>
> Як знаходити хороші тестові кейси? Корисне правило: почніть із простих випадків,
> які покривають базову функціональність. Потім додайте граничні випадки з обох
> боків: створіть один сценарій на межі здійсненності та ще один — трохи за
> межами. Будь-який сценарій з потенційним «off-by-one» — чудовий кандидат для
> граничного випадку.

### Мінімальний час відпочинку

**Обмеження мінімального часу відпочинку** забороняє медсестрі працювати дві
зміни надто близько одна до одної. Формально, для кожної медсестри й кожної
пари змін, якщо час між завершенням однієї та початком наступної менший за
потрібний період відпочинку, обидві не можуть бути призначені цій медсестрі.

#### Ключові тести

Щоб перевірити це обмеження, спершу тестуємо прості шаблони призначень:

- `[None, True, True, None]`: не здійсненно (дві послідовні зміни без відпочинку).
- `[True, False, True]`: здійсненно, якщо проміжок достатньо довгий.
- `[True, True]`: не здійсненно, якщо дві послідовні зміни перекриваються або
  порушують мінімальний відпочинок.

Використовуючи допоміжну функцію, можна легко запускати ці тести з різними
параметрами:

```python
def run_min_rest_test(
    assignments: list[bool|None],
    expected_feasible: bool,
    shift_length: int = 8,
    min_time_in_between: timedelta = timedelta(hours=16),
):
    shifts = create_shifts(len(assignments), shift_length=shift_length)
    nurse = create_nurse("Nurse A", min_time_between_shifts=min_time_in_between)
    instance = NurseRosteringInstance(nurses=[nurse], shifts=shifts)

    context = AssertModelFeasible() if expected_feasible else AssertModelInfeasible()
    with context as model:
        nurse_vars = NurseDecisionVars(nurse, shifts, model)
        MinTimeBetweenShifts().build(instance, model, [nurse_vars])
        for s, assign in zip(shifts, assignments):
            if assign is None:
                continue  # skip free assignments
            nurse_vars.fix(s.uid, assign)
```

Окремі тести можна визначити так:

```python
def test_min_time_between_shifts_infeasible_pattern():
    run_min_rest_test(
        assignments=[None, True, True, None],
        expected_feasible=False,
        shift_length=8,
        min_time_in_between=timedelta(hours=8),
    )
```

```python
def test_min_time_between_shifts_feasible_pattern():
    run_min_rest_test(
        assignments=[True, False, True],
        expected_feasible=True,
        shift_length=8,
        min_time_in_between=timedelta(hours=8),
    )
```

Додаткові тестові кейси (наприклад, одна зміна, всі false, та різні інтервали)
є в повному тестовому файлі, але тут ми їх опускаємо для ясності.

> [!WARNING]
>
> Для перевірки здійсненності слід фіксувати якомога більше призначень, адже
> кожне зафіксоване призначення зменшує свободу розв’язувача обходити обмеження.
> Для перевірки не здійсненності, навпаки, фіксуйте якнайменше призначень, щоб
> розв’язувач мав достатньо свободи шукати можливі шляхи обходу обмежень.

#### Реалізація

Для реалізації ми знаходимо для кожної зміни медсестри всі наступні зміни, які
порушили б мінімальний час відпочинку, якщо обидві призначені. Якщо перша
зміна призначена, то жодна з цих наступних змін не може бути призначена. Тут
ми можемо оптимізувати побудову моделі, використовуючи факт, що зміни
відсортовані за часом початку.

Простіша, але менш ефективна реалізація перевіряла б усі пари змін для кожної
медсестри й накладала обмеження, що тільки одна з них може бути призначена.

```python
class MinTimeBetweenShifts(ShiftAssignmentModule):
    def enforce_for_nurse(self, model: cp_model.CpModel, nurse_x: NurseDecisionVars):
        min_time_between_shifts = nurse_x.nurse.min_time_between_shifts
        for i in range(len(nurse_x.shifts) - 1):
            shift_i = nurse_x.shifts[i]
            colliding: list[Shift] = []  # shifts that are too close to shift_i
            for j in range(i + 1, len(nurse_x.shifts)):
                shift_j = nurse_x.shifts[j]
                if shift_i.end_time + min_time_between_shifts <= shift_j.start_time:
                    # Since shifts are sorted by start time, if the current shift_j starts
                    # after the required rest period, all subsequent shifts will also be valid.
                    # Therefore, we can safely break here to avoid unnecessary checks.
                    break
                colliding.append(shift_j)
            if colliding:
                # if there are shifts that are too close to shift_i,
                # prevent their assignment if shift_i is assigned
                shift_i_selected = nurse_x.is_assigned_to(shift_i.uid)
                no_colliding_selected = (
                    sum(nurse_x.is_assigned_to(s.uid) for s in colliding) == 0
                )
                model.add(no_colliding_selected).only_enforce_if(shift_i_selected)

    def build(self, instance, model, nurse_shift_vars):
        """
        Enforce minimum rest time between any two shifts for a nurse.
        """
        for nv in nurse_shift_vars:
            self.enforce_for_nurse(model, nv)
        return 0  # no objective contribution
```

### Задоволення попиту

У реальному світі кожна зміна потребує мінімальної кількості медсестер для
безпеки та ефективності. Цю вимогу описує **попит** зміни. Обмеження
задоволення попиту забезпечує, що кожній зміні призначено щонайменше стільки
медсестер, скільки вимагає її попит.

Щоб перевірити цю поведінку, використаємо прості тести. У першому тесті ми
створюємо одну зміну з попитом 2 і двома доступними медсестрами — це здійсненно.
У другому тесті ми блокуємо призначення однієї з медсестер, що порушує вимогу
попиту і робить модель не здійсненною.

```python
from nurserostering.modules import DemandSatisfactionModule
from nurserostering.nurse_vars import NurseDecisionVars
from cpsat_utils.testing import AssertModelFeasible, AssertModelInfeasible
from generate import create_shifts, create_nurse
from nurserostering.data_schema import NurseRosteringInstance

def test_demand_satisfaction_met():
    shifts = create_shifts(1)
    shifts[0].demand = 2
    nurse1 = create_nurse("N1")
    nurse2 = create_nurse("N2")
    instance = NurseRosteringInstance(nurses=[nurse1, nurse2], shifts=shifts)

    with AssertModelFeasible() as model:
        nurse_vars1 = NurseDecisionVars(nurse1, shifts, model)
        nurse_vars2 = NurseDecisionVars(nurse2, shifts, model)
        DemandSatisfactionModule().build(instance, model, [nurse_vars1, nurse_vars2])


def test_demand_satisfaction_understaffed():
    shifts = create_shifts(1)
    shifts[0].demand = 2
    nurse1 = create_nurse("N1")
    nurse2 = create_nurse("N2")
    instance = NurseRosteringInstance(nurses=[nurse1, nurse2], shifts=shifts)

    with AssertModelInfeasible() as model:
        nurse_vars1 = NurseDecisionVars(nurse1, shifts, model)
        nurse_vars2 = NurseDecisionVars(nurse2, shifts, model)
        DemandSatisfactionModule().build(instance, model, [nurse_vars1, nurse_vars2])
        nurse_vars2.fix(shifts[0].uid, False)
```

Відповідна реалізація обмеження така ж пряма: ми просто додаємо обмеження, що
загальна кількість призначених медсестер на зміну має бути не меншою за попит
цієї зміни.

```python
class DemandSatisfactionModule(ShiftAssignmentModule):
    """
    Ensure each shift meets its demand.
    """
    def build(
        self,
        instance: NurseRosteringInstance,
        model: cp_model.CpModel,
        nurse_shift_vars: list[NurseDecisionVars],
    ) -> cp_model.LinearExprT:
        for shift in instance.shifts:
            assigned_nurses = [
                nurse.is_assigned_to(shift_uid=shift.uid)
                for nurse in nurse_shift_vars
                if shift.uid in nurse._x
            ]
            model.add(sum(assigned_nurses) >= shift.demand)
        return 0
```

### Перевага штатних працівників

Тоді як попередні модулі визначали жорсткі обмеження, які мають бути виконані,
цей модуль вводить **м’яке обмеження**. Ми віддаємо перевагу призначенню
штатних медсестер над контрактними, адже контрактні можуть бути дорожчими або
менш бажаними з інших причин. Замість жорсткого правила ми **штрафуємо**
використання контрактних у цільовій функції. Так розв’язувач намагатиметься
мінімізувати кількість контрактних призначень, водночас задовольняючи всі
жорсткі обмеження.

**Приклад тесту:**

```python
from nurserostering.modules import PreferStaffModule, DemandSatisfactionModule
from cpsat_utils.testing import assert_objective
from generate import create_shifts, create_nurse

from nurserostering.nurse_vars import NurseDecisionVars
from nurserostering.data_schema import NurseRosteringInstance
from ortools.sat.python import cp_model


def test_prefer_staff_module():
    """
    Prefer assigning the staff nurse (objective = 0).
    """
    shifts = create_shifts(1)
    shifts[0].demand = 1

    staff = create_nurse("Staff", staff=True)
    contractor = create_nurse("Contractor", staff=False)
    instance = NurseRosteringInstance(nurses=[staff, contractor], shifts=shifts)

    model = cp_model.CpModel()
    vars_staff = NurseDecisionVars(staff, shifts, model)
    vars_contractor = NurseDecisionVars(contractor, shifts, model)
    solver = cp_model.CpSolver()
    staff_mod = PreferStaffModule()

    DemandSatisfactionModule().build(instance, model, [vars_staff, vars_contractor])
    model.minimize(staff_mod.build(instance, model, [vars_staff, vars_contractor]))

    assert_objective(model=model, solver=solver, expected=0.0)
    assert solver.value(vars_staff.is_assigned_to(shifts[0].uid)) == 1
    assert solver.value(vars_contractor.is_assigned_to(shifts[0].uid)) == 0
```

**Реалізація:**

```python
class PreferStaffModule(ShiftAssignmentModule):
    def build(
        self,
        instance: NurseRosteringInstance,
        model: cp_model.CpModel,
        nurse_shift_vars: list[NurseDecisionVars],
    ) -> cp_model.LinearExprT:
        """
        Penalize use of non-staff (contract) nurses in the objective.
        """
        expr = 0
        for nv in nurse_shift_vars:
            if not nv.nurse.staff:
                for uid in nv._x:
                    expr += instance.staff_weight * nv.is_assigned_to(uid)
        return expr
```

### Ціль за вподобаннями

Хоча багато попередніх модулів фокусувалися на обмеженнях, `MaximizePreferences`
інший: він визначає те, що ми насправді хочемо оптимізувати. Медсестри часто
мають вподобання щодо конкретних змін — наприклад, через особисті графіки,
відповідність навичок чи бажані години роботи. Хороший графік має враховувати
ці вподобання якомога більше.

Модуль `MaximizePreferences` кодує це, додаючи **негативний внесок** (нагороду)
до цільової функції, коли медсестру призначено на одну з її бажаних змін. Оскільки
наш інтерфейс мінімізує за замовчуванням, ми беремо вагу зі знаком мінус, щоб
бажані призначення зменшували загальне значення цілі. Зауважте, що ми могли
так само легко вказати, що вираз, який повертає `build`, треба максимізувати.

Отже, цей модуль — не м’яке обмеження, а **справжня ціль**: серед усіх
здійсненних графіків він спрямовує розв’язувач до максимізації задоволеності
медсестер.

**Приклад тесту:**

```python
from nurserostering.modules import MaximizePreferences, DemandSatisfactionModule
from cpsat_utils.testing import assert_objective
from generate import create_shifts, create_nurse

from nurserostering.nurse_vars import NurseDecisionVars
from nurserostering.data_schema import NurseRosteringInstance

from ortools.sat.python import cp_model


def test_maximize_preferences_module():
    """
    Prefer assigning the nurse to their preferred shift (objective = -1).
    """
    shifts = create_shifts(1)
    shifts[0].demand = 1

    nurse = create_nurse("Preferred Nurse", preferred_shifts={shifts[0].uid})
    instance = NurseRosteringInstance(nurses=[nurse], shifts=shifts)

    model = cp_model.CpModel()
    nurse_vars = NurseDecisionVars(nurse, shifts, model)
    solver = cp_model.CpSolver()
    pref_mod = MaximizePreferences()

    DemandSatisfactionModule().build(instance, model, [nurse_vars])
    model.minimize(pref_mod.build(instance, model, [nurse_vars]))

    assert_objective(model=model, solver=solver, expected=-1.0)
    assert (
        solver.value(nurse_vars.is_assigned_to(shifts[0].uid)) == 1
    ), "Nurse should be assigned to their preferred shift"
```

**Реалізація:**

```python
class MaximizePreferences(ShiftAssignmentModule):
    def build(
        self,
        instance: NurseRosteringInstance,
        model: cp_model.CpModel,
        nurse_shift_vars: list[NurseDecisionVars],
    ) -> cp_model.LinearExprT:
        """
        Reward assignments that match nurse preferences by reducing the objective value.
        """
        expr = 0
        for nv in nurse_shift_vars:
            for uid in nv.nurse.preferred_shifts:
                expr += -nv.nurse.preferred_shift_weight * nv.is_assigned_to(uid)
        return expr
```

## Повний розв’язувач

<!-- Представляє клас розв’язувача як оркестрацію всіх модулів -->

На цьому етапі ми реалізували всі необхідні модулі: обмеження, м’які обмеження
та цілі. Наступний крок — об’єднати ці компоненти в повну оптимізаційну модель.
Клас `NurseRosteringModel` відповідає за оркестрацію модулів, побудову CP-SAT
моделі та витягування розв’язку.

```python
from ortools.sat.python import cp_model
from .nurse_vars import NurseDecisionVars
from .data_schema import NurseRosteringInstance, NurseRosteringSolution
from .modules import (
    ShiftAssignmentModule,
    NoBlockedShiftsModule,
    DemandSatisfactionModule,
    MinTimeBetweenShifts,
    MaximizePreferences,
    PreferStaffModule,
)


class NurseRosteringModel:
    """
    A compact and extensible solver for the nurse rostering problem using CP-SAT.
    """

    def __init__(
        self, instance: NurseRosteringInstance, model: cp_model.CpModel | None = None
    ):
        self.instance = instance
        self.model = model or cp_model.CpModel()
        self.nurse_vars = [
            NurseDecisionVars(nurse, instance.shifts, self.model)
            for nurse in instance.nurses
        ]

        self.modules: list[ShiftAssignmentModule] = [
            NoBlockedShiftsModule(),
            DemandSatisfactionModule(),
            MinTimeBetweenShifts(),
            MaximizePreferences(),
            PreferStaffModule(),
        ]

        objective = sum(
            module.build(instance, self.model, self.nurse_vars)  # type: ignore
            for module in self.modules
        )
        self.model.minimize(objective)

    def solve(
        self,
        log_search_progress: bool = True,
        max_time_in_seconds: float = 60.0,
        **solver_params,
    ) -> NurseRosteringSolution:
        solver = cp_model.CpSolver()
        solver.parameters.log_search_progress = log_search_progress
        solver.parameters.max_time_in_seconds = max_time_in_seconds
        for key, value in solver_params.items():
            setattr(solver.parameters, key, value)

        status = solver.solve(self.model)
        if status == cp_model.INFEASIBLE:
            raise ValueError("The model is infeasible.")
        elif status not in (cp_model.OPTIMAL, cp_model.FEASIBLE):
            raise ValueError("Solver failed to find a feasible solution.")

        nurses_at_shifts = {}
        for nurse_model in self.nurse_vars:
            for shift_uid in nurse_model.extract(solver):
                nurses_at_shifts.setdefault(shift_uid, []).append(nurse_model.nurse.uid)

        return NurseRosteringSolution(
            nurses_at_shifts=nurses_at_shifts,
            objective_value=round(solver.objective_value),
        )
```

<!-- Представляє приклад тестового інстансу -->

Щоб продемонструвати повний робочий процес, протестуємо розв’язувач на
невеликому, але нетривіальному інстансі. Наступний тест налаштовує 7 днів із
3 змінами на день (ранкова, денна, нічна), що дає 21 зміну. Медсестри мають
різні вподобання, заблоковані зміни та обмеження, що створює цікаву задачу
складання графіка.

```python
def test_fixed_instance():
    base_date = datetime(2025, 1, 1)
    shift_length = 8
    shifts = []

    # 7 days, 3 shifts/day = 21 shifts
    for day in range(7):
        for idx, hour in enumerate([0, 8, 16]):  # Morning, Day, Night
            start = base_date + timedelta(days=day, hours=hour)
            end = start + timedelta(hours=shift_length)
            shifts.append(
                Shift(
                    name=f"Day {day+1} Shift {idx+1}",
                    start_time=start,
                    end_time=end,
                    demand=2 if hour == 8 else 1,  # Higher demand for day shifts
                )
            )

    # Total demand: 7*2 (day) + 7*1 (morning) + 7*1 (night) = 28 + 7 + 7 = 42 shifts needed

    nurses = [
        Nurse(
            name="Alice (prefers mornings, no Sundays)",
            preferred_shifts={s.uid for s in shifts if s.start_time.hour == 0},
            blocked_shifts={s.uid for s in shifts if s.start_time.weekday() == 6},
            staff=True,
            min_time_between_shifts=timedelta(hours=10),
            preferred_shift_weight=3,
        ),
        Nurse(
            name="Bob (prefers nights)",
            preferred_shifts={s.uid for s in shifts if s.start_time.hour == 16},
            blocked_shifts=set(),
            staff=True,
            min_time_between_shifts=timedelta(hours=10),
            preferred_shift_weight=3,
        ),
        Nurse(
            name="Clara (prefers weekends, blocks weekdays)",
            preferred_shifts={
                s.uid for s in shifts if s.start_time.weekday() in {5, 6}
            },
            blocked_shifts={s.uid for s in shifts if s.start_time.weekday() < 5},
            staff=True,
            min_time_between_shifts=timedelta(hours=10),
            preferred_shift_weight=2,
        ),
        Nurse(
            name="Dan (no preferences)",
            preferred_shifts=set(),
            blocked_shifts=set(),
            staff=True,
            min_time_between_shifts=timedelta(hours=8),
            preferred_shift_weight=1,
        ),
        Nurse(
            name="Eve (contractor, prefers day shifts)",
            preferred_shifts={s.uid for s in shifts if s.start_time.hour == 8},
            blocked_shifts=set(),
            staff=False,
            min_time_between_shifts=timedelta(hours=10),
            preferred_shift_weight=2,
        ),
        Nurse(
            name="Frank (prefers day shifts)",
            preferred_shifts={s.uid for s in shifts if s.start_time.hour == 8},
            blocked_shifts=set(),
            staff=True,
            min_time_between_shifts=timedelta(hours=10),
            preferred_shift_weight=2,
        ),
        Nurse(
            name="Grace (prefers mornings)",
            preferred_shifts={s.uid for s in shifts if s.start_time.hour == 0},
            blocked_shifts=set(),
            staff=True,
            min_time_between_shifts=timedelta(hours=10),
            preferred_shift_weight=3,
        ),
        Nurse(
            name="Heidi (contractor, no preferences)",
            preferred_shifts=set(),
            blocked_shifts=set(),
            staff=False,
            min_time_between_shifts=timedelta(hours=8),
            preferred_shift_weight=1,
        ),
    ]

    instance = NurseRosteringInstance(
        nurses=nurses, shifts=sorted(shifts, key=lambda s: s.start_time), staff_weight=2
    )

    model = NurseRosteringModel(instance)
    solution = model.solve()
    assert solution is not None, "The solution should not be None"
    assert_solution_is_feasible(instance, solution)
```

#### Медсестри

| Ім’я та опис                                   | Штат/Контракт    | Мін. відпочинок | Вподобання          | Заблоковані зміни |
| --------------------------------------------- | ---------------- | --------------- | ------------------- | ---------------- |
| **Alice** (надає перевагу ранкам, без неділь)  | Штат             | ≥ 10 год        | 7 змін (вага 3)     | 3 зміни          |
| **Bob** (надає перевагу ночам)                 | Штат             | ≥ 10 год        | 7 змін (вага 3)     | —                |
| **Clara** (надає перевагу вихідним, блокує будні) | Штат          | ≥ 10 год        | 6 змін (вага 2)     | 15 змін          |
| **Dan** (без уподобань)                        | Штат             | ≥ 8 год         | —                   | —                |
| **Eve** (контрактна, надає перевагу денним)    | Контракт         | ≥ 10 год        | 7 змін (вага 2)     | —                |
| **Frank** (надає перевагу денним)              | Штат             | ≥ 10 год        | 7 змін (вага 2)     | —                |
| **Grace** (надає перевагу ранкам)              | Штат             | ≥ 10 год        | 7 змін (вага 3)     | —                |
| **Heidi** (контрактна, без уподобань)          | Контракт         | ≥ 8 год         | —                   | —                |

#### Покриття змін

| День | Ранок (S1)          | День (S2)  | Ніч (S3)   |
| ---- | ------------------- | ---------- | ---------- |
| Д1   | Alice, Grace        | Dan, Frank | Bob        |
| Д2   | Alice, Grace        | Dan, Frank | Bob        |
| Д3   | Alice, Grace        | Eve, Frank | Bob        |
| Д4   | Alice, Clara, Grace | Dan, Frank | Bob        |
| Д5   | Clara, Grace        | Eve, Frank | Bob        |
| Д6   | Alice, Grace        | Eve, Frank | Bob        |
| Д7   | Alice, Grace        | Dan, Frank | Bob        |

## Автоматичне вилучення тестів із продакшну

Оскільки ми використовуємо pydantic для входів і виходів, серіалізація тестових
кейсів із продакшну доволі проста. Ви можете зберігати інстанси й розв’язки у
JSON та завантажувати їх пізніше для регресійних тестів.

```python
# export instance and solution to JSON
with open("instance.json", "w") as f:
    f.write(instance.model_dump_json())
with open("solution.json", "w") as f:
    f.write(solution.model_dump_json())
```

Потім ці файли можна завантажувати у тестах:

```python
from nurserostering.data_schema import NurseRosteringInstance, NurseRosteringSolution

def test_load_instance_and_solution():
    with open("instance.json", "r") as f:
        instance = NurseRosteringInstance.model_validate_json(f.read())
    with open("solution.json", "r") as f:
        solution = NurseRosteringSolution.model_validate_json(f.read())

    assert instance is not None, "Instance should not be None"
    assert solution is not None, "Solution should not be None"
    # should still be feasible
    assert_solution_is_feasible(instance, solution)

    # reoptimize the solution
    model = NurseRosteringModel(instance)
    new_solution = model.solve(max_time_in_seconds=10.0)
    assert new_solution is not None, "New solution should not be None"
    assert_solution_is_feasible(instance, new_solution)
    assert new_solution.objective_value == solution.objective_value, "Objective value should match"
```

Насправді можна просто складати їх у папку і змусити тест проходити всі файли в
цій папці. Замість того щоб записувати лише значення цілі в розв’язок, можна
також зберігати час розв’язання інстансу, що корисно для тестування
продуктивності. Зібравши набір таких файлів, можна почати рефакторити й
оптимізувати код із мінімальним ризиком регресій у коректності чи швидкодії.
Втім, пам’ятайте, що продуктивність CP-SAT (і подібних розв’язувачів) може
варіюватися між запусками, тож не будьте надто строгими в performance-тестах.

Замість того щоб покладатися лише на історичні дані для тестування, можна
**підтінювати** продакшн-модель розробницькою або експериментальною. Такий
підхід дозволяє не лише перевіряти коректність, а й безпосередньо порівнювати
продуктивність обох моделей, що дає високу впевненість: зміни покращують
модель, не ламаючи продакшн. Якщо у вас уже є інструмент моніторингу,
інтегрувати _shadow solutions_ зазвичай просто. Ця техніка настільки популярна,
що [nextmv](https://www.nextmv.io/docs/using-nextmv/experiments/shadow) має
вбудовану підтримку.

## Тестування на основі властивостей

Насамкінець коротко обговоримо тестування на основі властивостей. Річард
Обердік, старший оптимізатор із досвідом у тестуванні, віддає перевагу цьому
підходу і вважає юніт-тести менш придатними для своїх цілей. Він стверджує, що
оптимізаційні моделі важко декомпозувати, а тестування окремих рівнянь має
обмежену цінність.

Задачу в цьому розділі навмисно спрощено. У типових проєктах мої юніт-тести
націлені на обмеження або модулі, що складаються з наборів нижчорівневих
обмежень і рівнянь. Багато тестів, наведених тут, справді надлишкові для
спрощеного сценарію.

Ці спостереження підкреслюють, що не існує універсального робочого процесу
для всіх застосувань; не варто нав’язувати мій особистий стиль своїм потребам.
Я сам суттєво змінюю підхід залежно від задачі та контексту. Тестування на
основі властивостей може добре підійти вам, тому коротко окреслимо його
ключові ідеї.

Тестування на основі властивостей — це методологія, де ви задаєте загальні
властивості, які має задовольняти код, а інструмент автоматично генерує широкий
набір тестових випадків для перевірки цих властивостей. Цей підхід особливо
цінний для оптимізаційних задач, де простір розв’язків великий і складний.
Концептуально він нагадує автоматизоване вибіркове семплювання можливих входів
і перевірку, чи відповідні виходи задовольняють потрібні критерії.

На відміну від наївного випадкового тестування, бібліотеки на кшталт Hypothesis
використовують _стратегії_ для систематичного генерування входів і, якщо
виникає збій, намагаються **звужити** (shrink) невдалий випадок до мінімального
контрприкладу. Hypothesis також зберігає приклади, щоб збої можна було
відтворювати детерміновано.

Якщо вас, як і мене, спочатку вчили, що тести мають бути детермінованими, це
може здатися тривожним. Але на практиці достатньо один раз натрапити на баг —
потім ви додаєте детермінований регресійний тест, щоб він не повторився. Коли
ви не впевнені, які граничні випадки тестувати, property-based тестування дає
ефективний спосіб їх виявити.

Однією з найпоширеніших бібліотек Python для property-based тестування є
[Hypothesis](https://hypothesis.readthedocs.io/en/latest/). Вона дозволяє
визначати стратегії генерації тестових даних і автоматично запускає тести на
різноманітних входах.

> :video: Чіткий і захопливий вступ до property-based тестування з Hypothesis
> можна знайти в цьому
> [21-хвилинному YouTube-відео](https://www.youtube.com/watch?v=mkgd9iOiICc) від
> ArjanCode.

У property-based тестуванні керівні питання зазвичай мають такий вигляд:

- _Для будь-якого валідного інстансу моєї оптимізаційної задачі, чи повертає
  розв’язувач здійсненний розв’язок (або коректно повідомляє про не здійсненність)?_
- _Для будь-якого валідного інстансу задачі графіка медсестер, чи завжди
  достатньо персоналу, щоб покрити кожну зміну?_

Фраза «для будь-якого валідного інстансу» є ключовою: ви повинні вказати
Hypothesis, як генерувати входи, що задовольняють інваріанти схеми. Hypothesis
потім намагається спростувати ваше припущення, шукаючи контрприклади, часто
націлюючись на крайові випадки. Цей підхід **доповнює юніт-тести**: вам усе ще
потрібен невеликий набір чітких, детермінованих юніт-тестів для добре
зрозумілих компонентів, а property-based тести дозволяють досліджувати набагато
ширший простір входів без роздування тестового набору.

Почнімо з простого прикладу property-based тесту, щоб проілюструвати базову
ідею. У цьому випадку ми тестуємо вбудовану функцію `sorted` і перевіряємо три
властивості:

```python
from collections import Counter
from hypothesis import given, strategies as st

@given(st.lists(st.integers()))
def test_sort_properties(xs):
    sorted_xs = sorted(xs)

    # Property 1: Sorting does not change the length
    assert len(sorted_xs) == len(xs)

    # Property 2: Sorted list is monotonically non-decreasing
    for a, b in zip(sorted_xs, sorted_xs[1:]):
        assert a <= b

    # Property 3: Sorting does not lose or duplicate elements
    assert Counter(sorted_xs) == Counter(xs)
```

У цьому прикладі ми перевіряємо, що _для будь-якого списку цілих чисел_ застосування
`sorted` зберігає довжину списку, дає невід’ємно зростаючу послідовність і
повертає перестановку вхідних елементів. Hypothesis автоматично генерує
різноманітні списки цілих чисел, запускає тест і звужує будь-які збої до
найменшого контрприкладу.

<details>
<summary>Ось які входи hypothesis тестував автоматично:</summary>

- `[]`
- `[0]`
- `[26242, -1963]`
- `[-121]`
- `[8436]`
- `[15719]`
- `[-19093982987237563430026067407172463954]`
- `[-3922]`
- `[-3922, 1364]`
- `[-923437505601415702]`
- `[-923437505601415702, 1030000614]`
- `[-923437505601415702, -923437505601415702]`
- `[-28265]`
- `[-30093, -2983, -30440]`
- `[-30093, -30440, -30440]`
- `[-30093]`
- `[-40, 111940892136851798167905802830994768244, -28043, 7, 20215, 1370480367, 7446, -39]`
- `[-40, 111940892136851798167905802830994768244, -28043, 7, 20215, 1370480367, 20215, -39]`
- `[-40, 111940892136851798167905802830994768244, 111940892136851798167905802830994768244, 7, 20215, 1370480367, 20215, -39]`
- `[-40, 111940892136851798167905802830994768244, 111940892136851798167905802830994768244, 7, -39, 1370480367, 20215, -39]`
- `[-40, 111940892136851798167905802830994768244, 111940892136851798167905802830994768244, 7, 111940892136851798167905802830994768244, 1370480367, 20215, -39]`
- `[1370480367, 111940892136851798167905802830994768244, 111940892136851798167905802830994768244, 7, 111940892136851798167905802830994768244, 1370480367, 20215, -39]`
- `[1370480367, 1370480367, 111940892136851798167905802830994768244, 7, 111940892136851798167905802830994768244, 1370480367, 20215, -39]`
- `[8328, 6129]`
- `[8328]`
- `[-114, 12990, -114, 27, -16229, -19256, 928]`
- `[-114, 12990, -114, 27, -16229, -16229, 928]`
- `[-114, 12990, -114, 27, -16229, -114, 928]`
- `[-114, 12990, -114, -114, -16229, -114, 928]`
- `[-114, 12990, -114, -114, -16229, 928, 928]`
- `[-114, 12990, -114, -114, -16229, 928, -114]`
- `[-114, 12990, -114, -114, 928, 928, 928]`
- `[-7, -79, -1133414645]`
- `[-79, -79, -1133414645]`
- `[-79, -79, -79]`
- `[-1482, -30293, -23505, -7340]`
- `[-22323, 93]`
- `[-22323, -22323]`
- `[2353, 13157]`
- `[2353, 2353]`
- `[2353]`
- `[7714]`
- `[13297, -12682, -26, 2588, -5696, 18, 10030, 22]`
- `[13297, -12682, -26, 2588, -5696, 18, 22, 22]`
- `[13297, -12682, -26, 2588, -5696, 18]`
- `[13297, 2588, -26, 2588, -5696, 18]`
- `[13297, 2588, -26]`
- `[23480, -82, 46, 26111, 32207, -3830610785522322019, 63408623014671325114394083743435908480, 61, -20775, -1100012486, 0, -5724957629946085877, -1248, 64, 21, 13771, 721, 4, 81, -11615, -75, -31640, -15547, -5831, 2113]`
- `[23480, -82, 46, 26111, 32207, -3830610785522322019, 63408623014671325114394083743435908480, 61, -20775, -1100012486, 0, -5724957629946085877, -1248, 64, 21, 2113, 721, 4, 81, -11615, -75, -31640, -15547, -5831, 2113]`
- `[23480, -82, 46, 26111, 32207, -3830610785522322019, 63408623014671325114394083743435908480, 61, -20775, -1100012486, 0, -5724957629946085877, -1248, 64, 21]`
- `[23480, -82, 46, 26111, 32207, -3830610785522322019, 63408623014671325114394083743435908480, 61, -20775, -1100012486, 0, -5724957629946085877, -1248, 21, 21]`
- `[23480, -82, -1248, 26111, 32207, -3830610785522322019, 63408623014671325114394083743435908480, 61, -20775, -1100012486, 0, -5724957629946085877, -1248, 21, 21]`
- `[23480, -82, -1248, 26111, 32207, -3830610785522322019, 63408623014671325114394083743435908480, 61, -20775, -1100012486, 0, -5724957629946085877, -1248, 61, 21]`
- `[23480, -82, -1248, 26111, 63408623014671325114394083743435908480, -3830610785522322019, 63408623014671325114394083743435908480, 61, -20775, -1100012486, 0, -5724957629946085877, -1248, 61, 21]`
- `[-78711666441691544779522005139678058413, 9413, -28, -25429, 1138913225, 119, 15206, -14631, 13620, 22066, 73, -930]`
- `[-78711666441691544779522005139678058413, 22066, -28, -25429, 1138913225, 119, 15206, -14631, 13620, 22066, 73, -930]`
- `[-78711666441691544779522005139678058413, 22066, -28, 119, 1138913225, 119, 15206, -14631, 13620, 22066, 73, -930]`
- `[-78711666441691544779522005139678058413, 15206, -28, 119, 1138913225, 119, 15206, -14631, 13620, 22066, 73, -930]`
- `[119, 15206, -28, 119, 1138913225, 119, 15206, -14631, 13620, 22066, 73, -930]`
- `[119, 15206, -28, 73, 1138913225, 119, 15206, -14631, 13620, 22066, 73, -930]`
- `[119, 15206, -28, 73, 1138913225, 73, 15206, -14631, 13620, 22066, 73, -930]`
- `[-10367, -28534]`
- `[-10367, -10367]`
- `[-15, -97, 20993, 86, -3483807830384175452, 17981, 5590988155335024430, 21910677380750136143640822796681648827, -11734, 10, -23457]`
- `[-15, -97, 20993, 86, -3483807830384175452, 17981, 5590988155335024430, -11734, -11734, 10, -23457]`
- `[-15, -97, 20993, 86, -3483807830384175452, 17981, 5590988155335024430, -23457, -11734, 10, -23457]`
- `[-15, 10, 20993, 86, -3483807830384175452, 17981, 5590988155335024430, -23457, -11734, 10, -23457]`
- `[-15, 10, 20993, 86, -3483807830384175452, 17981, 5590988155335024430, -11734, -11734, 10, -23457]`
- `[-15, 10, 20993, 86, -3483807830384175452, 17981, 5590988155335024430, -11734, 17981, 10, -23457]`
- `[29141, -30, -5793, 102, -16130, -5, -9949, 676613804, -61, 12368]`
- `[29141, -30, -5793, 102, 676613804, -5, -9949, 676613804, -61, 12368]`
- `[-61, -30, -5793, 102, 676613804, -5, -9949, 676613804, -61, 12368]`
- `[-61, -9949, -5793, 102, 676613804, -5, -9949, 676613804, -61, 12368]`
- `[-61, -9949, 12368, 102, 676613804, -5, -9949, 676613804, -61, 12368]`
- `[-61, -9949, 12368, 102, 676613804, -5, -61, 676613804, -61, 12368]`
- `[105, -124, 29994, 4704, 23985, 5651302969633935431, -21152, 476047859, 23285, 7392, 12]`
- `[23285, -124, 29994, 4704, 23985, 5651302969633935431, -21152, 476047859, 23285, 7392, 12]`
- `[23285, -124, 29994, 4704, 5651302969633935431, 5651302969633935431, -21152, 476047859, 23285, 7392, 12]`
- `[23285, -124, 29994, 23285, 5651302969633935431, 5651302969633935431, -21152, 476047859, 23285, 7392, 12]`
- `[23285, -124, 29994, 23285, 7392, 5651302969633935431, -21152, 476047859, 23285, 7392, 12]`
- `[23285, -124, 29994, 7392, 7392, 5651302969633935431, -21152, 476047859, 23285, 7392, 12]`
- `[2105491908, 8597804526551328604, 7275042865703570734]`
- `[2105491908, 2105491908, 7275042865703570734]`
- `[2105491908, 7275042865703570734, 7275042865703570734]`
- `[7275042865703570734, 2105491908, 7275042865703570734]`
- `[2105491908, 2105491908, 2105491908]`
- `[29243, -1704064901, 29484]`
- `[29243, 29484, 29484]`
- `[29484, 29484, 29484]`
- `[-19703, -88, -6578, 121]`
- `[1070832594, 17504]`
- `[1070832594, 1070832594]`
- `[-69]`
- `[15301, 479652285201667946]`
- `[479652285201667946, 479652285201667946]`
- `[479652285201667946]`
- `[516195269, 10059, -61, -106, 6213, -83, -15699]`
- `[6213, 10059, -61, -106, 6213, -83, -15699]`
- `[6213, 10059, -61, -106, 6213, -83, -83]`
- `[6213, 10059, -61, -106, -83, -83, -83]`
</details>

Тепер застосуємо property-based тестування до задачі графіка медсестер. Головний
виклик — визначити стратегію, яка генерує валідні інстанси задачі. Зокрема,
згенеровані інстанси мають відповідати схемі даних: унікальні UID-и; валідні
часові інтервали для змін; і узгоджені посилання між медсестрами, змінами та
призначеннями. Оскільки сконструювати інстанси, що завжди здійсненні, важко,
ми перевіряємо таку властивість: протягом фіксованого ліміту часу розв’язувач
або повертає здійсненний розв’язок, який проходить незалежну валідацію, або
повідомляє, що інстанс не здійсненний чи невідомий. Такий вибір може не
виявити хибні не здійсненності, але для ілюстративного прикладу достатній.

```python
from datetime import datetime, timedelta
from hypothesis import given, strategies as st
from hypothesis.strategies import composite
from nurserostering.data_schema import NurseRosteringInstance, Shift, Nurse
from nurserostering.solver import NurseRosteringModel
from nurserostering.validation import assert_solution_is_feasible


# --- Helper strategies ---

# A datetime in Jan 2025
_dt_jan_2025 = st.datetimes(
    min_value=datetime(2025, 1, 1, 0, 0, 0),
    max_value=datetime(2025, 1, 31, 23, 59, 59),
)

@composite
def shift_strategy(draw):
    """
    Build a Shift with end_time > start_time.
    """
    name = draw(st.text(min_size=1, max_size=10))
    start = draw(_dt_jan_2025)

    # Duration between 4h and 12h
    duration_hours = draw(st.integers(min_value=4, max_value=12))
    end = start + timedelta(hours=duration_hours)

    # Demand can be zero per schema (NonNegativeInt); keep small
    demand = draw(st.integers(min_value=0, max_value=3))

    # uid is auto-generated by schema default_factory
    return Shift(
        name=name,
        start_time=start,
        end_time=end,
        demand=demand,
    )

def _subset_of_uids(shift_uids, max_size=5):
    """
    Produce a strategy for a set subset of the given shift_uids.
    """
    # sampled_from requires a sequence, not a set
    return st.sets(
        st.sampled_from(list(shift_uids)),
        max_size=max_size,
    )

@composite
def nurse_strategy(draw, shift_uids):
    """
    Build a Nurse whose preferred/blocked sets are subsets of the provided shift_uids.
    """
    name = draw(st.text(min_size=1, max_size=10))
    staff = draw(st.booleans())
    min_tbs = timedelta(hours=8)  # fixed, as in your original
    pref_weight = draw(st.integers(min_value=0, max_value=5))  # NonNegativeInt

    # Independent subsets; may overlap (schema does not forbid)
    preferred = draw(_subset_of_uids(shift_uids, max_size=5))
    blocked = draw(_subset_of_uids(shift_uids, max_size=5))

    # uid is auto-generated by schema default_factory
    return Nurse(
        name=name,
        preferred_shifts=preferred,
        blocked_shifts=blocked,
        staff=staff,
        min_time_between_shifts=min_tbs,
        preferred_shift_weight=pref_weight,
    )

@composite
def instance_strategy(draw):
    """
    Build a NurseRosteringInstance that passes all schema validators:
    - Unique nurse/shift UIDs (handled by defaults).
    - Shifts sorted by start_time.
    - Nurses' preference/blocked sets reference existing shift UIDs.
    """
    # Make and sort shifts by start_time
    num_shifts = draw(st.integers(min_value=10, max_value=20))
    shifts = [draw(shift_strategy()) for _ in range(num_shifts)]
    shifts.sort(key=lambda s: s.start_time)

    shift_uids = [s.uid for s in shifts]

    # Build nurses referencing these shift_uids
    num_nurses = draw(st.integers(min_value=5, max_value=10))
    nurses = [draw(nurse_strategy(shift_uids)) for _ in range(num_nurses)]

    staff_weight = draw(st.integers(min_value=0, max_value=5))

    return NurseRosteringInstance(
        nurses=nurses,
        shifts=shifts,
        staff_weight=staff_weight,
    )


# --- Property test ---

@given(instance=instance_strategy())
def test_solver_finds_feasible_solution(instance):
    model = NurseRosteringModel(instance)
    try:
        solution = model.solve(max_time_in_seconds=10.0)
        assert_solution_is_feasible(instance, solution)
    except ValueError:
        # If the model is infeasible, we accept that as a valid outcome.
        # Ensuring that the input is feasible would be a little more complex.
        pass
```

> :reference:
>
> Див. репозиторій Річарда Обердіка
> [прикладовий репозиторій](https://github.com/RichardOberdieck/opti_test), який
> демонструє property-based тестування для оптимізаційної задачі з Hypothesis.
> Перегляньте
> [/docs](https://github.com/RichardOberdieck/opti_test/tree/main/docs)
> каталог для додаткових пояснень; зауважте, що документація наразі неповна.

## Висновок

У цьому розділі ми розробили повний розв’язувач графіка медсестер на CP-SAT у
рамках test-driven підходу. Модульний дизайн дозволив відокремити обмеження від
цілей, створити сфокусовані тести й ітеративно вдосконалювати рішення з
впевненістю. Хоч цей підхід не завжди найшвидший шлях до робочого розв’язку,
він дуже ефективний для задач, що еволюціонують з часом.

Ми також підкреслили альтернативні підходи — такі як табличне представлення
даних і property-based тестування — наголошуючи, що варто обирати методи, які
найкраще відповідають вашому контексту. Ключовий висновок: принципи інженерії
ПЗ можна успішно застосовувати до оптимізаційного моделювання, підвищуючи
надійність і підтримуваність.

> [!TIP]
>
> Цей розділ переважно зосереджувався на коректності. Однак, щойно розв’язок
> працює правильно, може виявитися, що він недостатньо масштабується. У розділі
> [Бенчмаркінг вашої моделі](#08-benchmarking) ви дізнаєтеся, як бенчмаркувати
> моделі для оцінки покращень продуктивності та масштабованості. Розроблений
> тут тестовий фреймворк допомагає підтримувати коректність під час
> оптимізації продуктивності. Часто підвищення ефективності передбачає невеликі
> зміни постановки задачі — наприклад, наближення нелінійних елементів лінійними
> або послаблення обмежень, які зазвичай можна виправити в постобробці з мінімальною
> втратою якості розв’язку. Адаптація цих змін може вимагати корекцій у тестах,
> але зазвичай багато з них можна використати повторно.
